"""
Shell command handling for UaiBot in a modular structure.
This version removes the send_to_screen_session method and uses the ScreenManager instead.
"""
import subprocess
import shlex
import os
import platform
import json
from core.utils import get_platform_name
from device_manager.usb_detector import USBDetector

try:
    from core.platform_commands import get_platform_command
except ImportError:
    # Define a placeholder if the module is not available
    def get_platform_command(platform, command_type, subtype=None):
        return None

# Basic list of commands that are generally safe.
SAFE_COMMAND_WHITELIST = [
    # Basic navigation and file operations
    'ls', 'cd', 'pwd', 'echo', 'cat', 'mkdir', 'rmdir', 'cp', 'mv', 'find', 'grep',
    # Programming and development tools
    'python', 'python3', 'pip', 'git', 'man', 'uname',
    # System information and management
    'df', 'du', 'free', 'top', 'ps', 'kill', 'killall', 'uptime', 'cal', 'date',
    # macOS specific commands
    'osascript', 'screen', 'open', 'softwareupdate', 'caffeinate', 'say',
    # Text editors and viewers
    'nano', 'vi', 'vim', 'less', 'more', 'head', 'tail',
    # Network tools
    'ping', 'curl', 'wget', 'ssh', 'scp', 'telnet', 'netstat', 'ifconfig', 'traceroute', 'nslookup',
    # Text processing
    'grep', 'awk', 'sed', 'sort', 'uniq', 'wc', 'diff', 'pbcopy', 'pbpaste',
    # File management
    'touch', 'ditto', 'chmod', 'chown', 'chgrp', 'ln',
    # System commands
    'history', 'crontab', 'alias', 'which', 'whereis', 'whoami', 'who', 'w', 
    # Advanced macOS commands
    'networksetup', 'airport', 'scutil', 'mdfind', 'diskutil', 'system_profiler', 
    'sw_vers', 'sysctl', 'pmset', 'launchctl', 'defaults', 'plutil', 'hdiutil', 
    'screencapture', 'security', 'xcode-select', 'xcodebuild', 'xcrun', 'codesign', 
    'spctl', 'ioreg', 'pkgutil', 'automator', 'afplay'
]

# Commands that should always require confirmation or be blocked in certain modes.
POTENTIALLY_DANGEROUS_COMMANDS = [
    'rm', 'sudo', 'mkfs', 'shutdown', 'reboot', 'dd', 'fdisk', 'kill', 
    'chmod', 'chown', 'chgrp', 'mv', 'cp', 'rmdir', 'ln -s', 'format',
    'diskutil', 'diskpart', 'parted', 'gparted', '> /dev/', '| sudo', 
    'mkfs', 'fsck', 'mount', 'umount', ':(){', 'eval', 'dmesg'
]

class ShellHandler:
    def __init__(self, safe_mode=True, enable_dangerous_command_check=True, suppress_prompt=False, quiet_mode=False):
        """
        Initializes the ShellHandler.
        Args:
            safe_mode (bool): If True, restricts execution to whitelisted commands.
            enable_dangerous_command_check (bool): If True, checks commands against POTENTIALLY_DANGEROUS_COMMANDS.
            suppress_prompt (bool): If True, does not prompt for confirmation.
            quiet_mode (bool): If True, reduces unnecessary terminal output.
        """
        self.safe_mode = safe_mode
        self.enable_dangerous_command_check = enable_dangerous_command_check
        self.suppress_prompt = suppress_prompt
        self.quiet_mode = quiet_mode
        self.system_platform = platform.system().lower()
        self.platform_name = get_platform_name()
        
        # Will be assigned externally
        self.screen_manager = None
        
        # Create a USB device detector
        self.usb_detector = USBDetector(quiet_mode=quiet_mode)
        
        if not self.quiet_mode:
            print(f"ShellHandler initialized. Safe mode: {self.safe_mode}, Dangerous command check: {self.enable_dangerous_command_check}")
    
    def log(self, message):
        """Print a message if not in quiet mode"""
        if not self.quiet_mode:
            print(message)
    
    # Update safe commands for the current platform
    def _update_safe_commands_for_platform(self):
        """Update safe commands list with platform-specific commands"""
        # Platform-specific commands are already included in the whitelist
        pass
    
    def _is_command_safe(self, command_parts):
        """Checks if the command is on the whitelist."""
        if not command_parts:
            return False
        command_name = command_parts[0]

        # Add platform-specific commands to the safe list
        self._update_safe_commands_for_platform()
        
        if command_name in SAFE_COMMAND_WHITELIST:
            return True
        
        # Basic check for path-like commands (e.g. /bin/ls)
        if '/' in command_name and command_name.split('/')[-1] in SAFE_COMMAND_WHITELIST:
            return True

        return False

    def _is_potentially_dangerous(self, command_parts):
        """Checks if the command is in the list of potentially dangerous commands."""
        if not command_parts:
            return False
        command_name = command_parts[0]
        
        if command_name in POTENTIALLY_DANGEROUS_COMMANDS:
            return True
        # Check for sudo usage with another command
        if command_name == 'sudo' and len(command_parts) > 1 and command_parts[1] in POTENTIALLY_DANGEROUS_COMMANDS:
            return True
        return False
    
    def _fix_platform_command(self, command_string):
        """Adjust command based on platform if needed"""
        # Simple pass-through for now, can be extended in the future
        return command_string
    
    def execute_command(self, command_string, force_shell=False, require_confirmation_for_shell=True):
        """Execute a shell command and return the output"""
        try:
            # Clean up the command string
            command_string = command_string.strip()
            
            # Remove markdown code block markers and backticks
            if command_string.startswith('```'):
                while command_string.startswith('`'):
                    command_string = command_string[1:]
                end_pos = command_string.rfind('```')
                if end_pos != -1:
                    command_string = command_string[:end_pos]
            elif command_string.startswith('`') and command_string.endswith('`'):
                command_string = command_string[1:-1]
                
            # Remove language hints from the start
            first_line_end = command_string.find('\n')
            if first_line_end != -1:
                first_line = command_string[:first_line_end].strip().lower()
                if first_line in ['bash', 'shell', 'zsh', 'sh', 'cmd', 'powershell']:
                    command_string = command_string[first_line_end + 1:]
            
            # Remove any remaining backticks
            command_string = command_string.replace('`', '').strip()
            
            if not command_string.strip():
                return "Error: No command provided after processing."

            # Check for and fix platform-specific commands
            command_string = self._fix_platform_command(command_string)
            self.log(f"Attempting to execute: {command_string}")

            # Special handling for commands that need shell=True
            if ('*' in command_string or '?' in command_string or 
                '|' in command_string or '>' in command_string or 
                '<' in command_string or ';' in command_string or  
                '&&' in command_string or '`' in command_string or '$(' in command_string):
                self.log(f"Using shell=True for command with special syntax: {command_string}")
                force_shell = True

            # Special handling for device path commands
            if (command_string.startswith('ls /dev') or 
                any(cmd in command_string for cmd in ['screen /dev', 'cat /dev', 'echo > /dev', 'stty -f /dev'])):
                self.log(f"Using shell=True for command with device paths: {command_string}")
                force_shell = True

            # Special handling for screen command
            if command_string.startswith('screen '):
                self.log("Using special handling for screen command")
                return subprocess.run(command_string, text=True, shell=True, 
                                     stdout=subprocess.PIPE, stderr=subprocess.PIPE).stderr or "Screen command executed"
                
            # Special handling for USB device queries
            if ('usb' in command_string.lower() or 'dev/tty' in command_string.lower() or 'dev/cu' in command_string.lower()) and \
               any(cmd in command_string.lower() for cmd in ['list', 'show', 'check', 'find']):
                self.log("Using USB detector for device query")
                return self.usb_detector.get_usb_devices()
                
            # Special handling for 'cd' command
            if command_string.strip().startswith('cd '):
                parts = shlex.split(command_string)
                if len(parts) > 1:
                    path_to_change = os.path.expanduser(parts[1])
                    try:
                        os.chdir(path_to_change)
                        return f"Changed directory to {os.getcwd()}"
                    except Exception as e:
                        return f"Error changing directory: {str(e)}"
                else: # just 'cd' often means go to home directory
                    try:
                        home_dir = os.path.expanduser('~')
                        os.chdir(home_dir)
                        return f"Changed directory to {os.getcwd()}"
                    except Exception as e:
                        return f"Error changing to home directory: {str(e)}"

            # Execute command
            if not force_shell:
                try:
                    # Split command and execute
                    command_parts = shlex.split(command_string)
                    if not command_parts:
                        return "Error: Command is empty after parsing."

                    command_name = command_parts[0]

                    if self.safe_mode and not self._is_command_safe(command_parts):
                        return f"Error: Command '{command_name}' is not in the allowed list in safe mode."

                    if self.enable_dangerous_command_check and self._is_potentially_dangerous(command_parts):
                        if self.safe_mode:
                            return f"Error: Execution of potentially dangerous command '{command_string}' blocked in safe mode."
                        self.log(f"Warning: Command '{command_string}' is potentially dangerous.")

                    # Execute without shell=True
                    self.log(f"Executing with shlex: {command_parts}")
                    result = subprocess.run(command_parts, capture_output=True, text=True, check=False)
                except ValueError as e:
                    # If shlex can't parse the command, try with shell=True if permitted
                    self.log(f"Error parsing command with shlex: {str(e)}")
                    if not self.safe_mode or force_shell:
                        self.log(f"Falling back to shell=True for: {command_string}")
                        result = subprocess.run(command_string, shell=True, capture_output=True, text=True, check=False)
                    else:
                        return f"Error: Could not parse command '{command_string}'. Try simplifying or using quotes properly."
            else: # force_shell is True
                if require_confirmation_for_shell and not self.suppress_prompt and self.safe_mode:
                    self.log(f"Warning: Executing command '{command_string}' with shell=True.")
                    if self.safe_mode:
                        self.log("Shell=True allowed without confirmation due to special command needs.")
                
                self.log(f"Executing with shell=True: {command_string}")
                result = subprocess.run(command_string, shell=True, capture_output=True, text=True, check=False)

            # Process command output
            if result.returncode != 0:
                error_message = f"Error executing command: {command_string}"
                error_message += f"\nReturn Code: {result.returncode}"
                if result.stdout:
                    error_message += f"\nStdout:\n{result.stdout.strip()}"
                if result.stderr:
                    error_message += f"\nStderr:\n{result.stderr.strip()}"
                self.log(error_message)
                return result.stderr.strip() if result.stderr else f"Command failed with return code {result.returncode}"
            return result.stdout.strip()
        
        except Exception as e:
            return f"An unexpected error occurred: {str(e)}"
    
    def detect_command_target(self, command, context=""):
        """
        Determine if a command should go to the screen session or local system.
        
        Args:
            command (str): The command to analyze
            context (str): Additional context text that might hint at target
            
        Returns:
            str: "SCREEN", "LOCAL", or "UNKNOWN"
        """
        # If explicit screen indicators in context, prefer screen
        screen_indicators = [
            "screen", "serial", "usb", "terminal session", "device", 
            "remote", "remote system", "remote machine", "other os", 
            "other machine", "screened", "over usb", "over the usb", 
            "connected device", "through screen"
        ]
        
        if any(indicator in context.lower() for indicator in screen_indicators):
            return "SCREEN"
            
        # Check if command is a direct file/navigation command
        nav_commands = ['ls', 'pwd', 'cd', 'dir']
        sys_commands = ['top', 'ps', 'df', 'du', 'uptime', 'date', 'whoami', 'who']
        
        # Split the command to get the base command
        command_parts = command.split()
        base_command = command_parts[0] if command_parts else ""
        
        # Navigation commands with no args are ambiguous
        if base_command in nav_commands and len(command_parts) == 1:
            # Check if we have a USB/serial context
            if any(term in context.lower() for term in ["usb", "serial", "device", "screen"]):
                return "SCREEN"
            else:
                return "LOCAL"
                
        # System information commands typically run locally
        if base_command in sys_commands:
            return "LOCAL"
            
        # Mac-specific commands almost always run locally
        mac_commands = ['open', 'say', 'pbcopy', 'pbpaste', 'networksetup', 'airport',
                        'system_profiler', 'sw_vers', 'defaults', 'osascript']
        if base_command in mac_commands:
            return "LOCAL"
            
        # If we can't determine, default to LOCAL for safety
        return "LOCAL"
    
    def check_command_safety_level(self, command_string):
        """
        Checks the safety level of a command string.
        
        Returns:
            str: Safety level
        """
        try:
            # Quick pass to see if command is empty
            if not command_string or not command_string.strip():
                return "EMPTY"
                
            # Check for special characters that might need shell=True
            contains_wildcards = '*' in command_string or '?' in command_string
            special_operators = ['|', '>', '<', ';', '&&', '||', '`', '$(']
            contains_special = any(op in command_string for op in special_operators)
            
            if contains_wildcards or contains_special:
                return "REQUIRES_SHELL_TRUE_ASSESSMENT"
            
            # Parse command with shlex
            try:
                command_parts = shlex.split(command_string)
                if not command_parts:
                    return "EMPTY"
                    
                # Check against our safe and dangerous lists
                if self._is_command_safe(command_parts):
                    if self._is_potentially_dangerous(command_parts):
                        return "POTENTIALLY_DANGEROUS"
                    else:
                        return "SAFE"
                else:
                    return "NOT_IN_WHITELIST"
                    
            except ValueError:
                return "REQUIRES_SHELL_TRUE_ASSESSMENT"
                
        except Exception as e:
            self.log(f"Error in check_command_safety_level: {str(e)}")
            return "ERROR_ASSESSING"
            
        return "SAFE"
    
    def find_folders(self, folder_name, location="~", max_results=20, include_cloud=True):
        """
        Find folders matching a given name pattern.
        
        Args:
            folder_name (str): Name pattern to search for
            location (str): Root directory to start the search
            max_results (int): Maximum number of results to return
            include_cloud (bool): Whether to include cloud storage folders
            
        Returns:
            str: Formatted search results
        """
        folder_name = folder_name.replace('"', '\"').replace("'", "\'")  # Escape quotes
        location = os.path.expanduser(location)
        
        try:
            # Prepare results containers
            all_folders = []
            cloud_folders = []
            
            # First check for platform-specific notes folders
            if include_cloud and folder_name.lower() in ["notes", "note", "notes app"]:
                if self.system_platform == "darwin":
                    # Try to find iCloud Notes folders
                    icloud_path = os.path.expanduser("~/Library/Mobile Documents/com~apple~Notes")
                    if os.path.exists(icloud_path):
                        try:
                            # Count total notes in root
                            notes_count = 0
                            for root, dirs, files in os.walk(icloud_path):
                                # Count just files in the root iCloud notes folder
                                if root == icloud_path:
                                    for file in files:
                                        if file.endswith('.icloud') or file.endswith('.notesdata'):
                                            notes_count += 1
                            
                            cloud_folders.append({"name": "Notes", "path": "iCloud/Notes", "type": "iCloud", "items": str(notes_count)})
                            
                            # Check for actual iCloud folders
                            cloud_subfolders = []
                            notes_dirs = os.path.join(icloud_path, "Notes")
                            if os.path.exists(notes_dirs):
                                try:
                                    for item in os.listdir(notes_dirs):
                                        subfolder_path = os.path.join(notes_dirs, item)
                                        if os.path.isdir(subfolder_path):
                                            # Count notes in this subfolder
                                            items_count = 0
                                            for root, dirs, files in os.walk(subfolder_path):
                                                items_count += len(files)
                                            
                                            cloud_subfolders.append({
                                                "name": item, 
                                                "items": str(items_count)
                                            })
                                except Exception as e:
                                    if not self.quiet_mode:
                                        print(f"Error scanning Notes subfolders: {e}")
                            
                            for subfolder in cloud_subfolders:
                                cloud_folders.append({
                                    "name": subfolder["name"], 
                                    "path": f"iCloud/Notes/{subfolder['name']}", 
                                    "type": "iCloud", 
                                    "items": subfolder["items"]
                                })
                        except Exception as e:
                            if not self.quiet_mode:
                                print(f"Error scanning iCloud Notes folders: {e}")
                            # Fallback for Notes folder if scanning fails
                            cloud_folders.append({"name": "Notes", "path": "iCloud/Notes", "type": "iCloud", "items": "Unknown"})
                        
                        # Also check for local Notes container
                        local_notes = os.path.expanduser("~/Library/Containers/com.apple.Notes")
                        if os.path.exists(local_notes):
                            cloud_folders.append({"name": "Notes App", "path": "Notes App (Local)", "type": "Local", "items": "Notes App Data"})
                
                elif self.system_platform == "windows":
                    # Try to identify common Windows Notes locations
                    note_locations = [
                        os.path.expanduser("~/Documents/OneNote Notebooks"),
                        os.path.expanduser("~/OneDrive/Documents/OneNote Notebooks"),
                        "C:/Program Files (x86)/Microsoft Office/Office16/ONENOTE.EXE",
                        "C:/Program Files/Microsoft Office/Office16/ONENOTE.EXE",
                        os.path.expanduser("~/AppData/Local/Packages/Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe")
                    ]
                    
                    for note_path in note_locations:
                        if os.path.exists(note_path):
                            if "OneNote" in note_path:
                                cloud_folders.append({"name": "OneNote Notebooks", "path": note_path, "type": "Microsoft", "items": "OneNote"})
                            elif "StickyNotes" in note_path:
                                cloud_folders.append({"name": "Sticky Notes", "path": note_path, "type": "Microsoft", "items": "Sticky Notes"})
                            elif "ONENOTE.EXE" in note_path:
                                cloud_folders.append({"name": "OneNote Application", "path": note_path, "type": "Microsoft", "items": "OneNote App"})
                
                elif self.system_platform == "linux":
                    # Check for GNOME Notes (Bijiben)
                    note_locations = [
                        os.path.expanduser("~/.local/share/bijiben"),
                        "/usr/bin/bijiben",
                        os.path.expanduser("~/.var/app/org.gnome.Notes")
                    ]
                    
                    for note_path in note_locations:
                        if os.path.exists(note_path):
                            cloud_folders.append({"name": "GNOME Notes", "path": note_path, "type": "Linux", "items": "Notes App"})
            
            # Construct the find command with error redirection for filesystem folders
            command = f'find {location} -type d -name "*{folder_name}*" 2>/dev/null | grep -v "Library/|.Trash" | head -n {max_results}'
            
            # Execute the command
            result = self.execute_command(command, force_shell=True)
            
            # Process filesystem results
            if result and result.strip() != "":
                all_folders = result.strip().split("\n")
            
            # Format the output with emojis according to enhancement guidelines
            if not all_folders and not cloud_folders:
                return f"No folders matching '{folder_name}' found in {location}."
                
            formatted_result = f"üìÇ Found folders matching '{folder_name}':\n\n"
            
            # First show cloud folders (if any)
            if cloud_folders:
                if self.system_platform == "darwin":
                    formatted_result += "üå•Ô∏è  iCloud:\n\n"
                elif self.system_platform == "windows":
                    formatted_result += "üìù  Note Applications:\n\n"
                else:
                    formatted_result += "üìù  Notes:\n\n"
                    
                # Show all folders with type and count
                for cf in cloud_folders:
                    formatted_result += f"  ‚Ä¢ {cf['name']}    {cf['items']}\n"
                        
                formatted_result += "\n"
            
            # Then show filesystem folders if we have any
            if all_folders:
                formatted_result += "üíª Local Filesystem:\n\n"
                for folder in all_folders:
                    formatted_result += f"  ‚Ä¢ {folder}\n"
                    
                if len(all_folders) >= max_results:
                    formatted_result += f"\n‚ö†Ô∏è  Showing first {max_results} results. To see more, specify a narrower search."
            
            return formatted_result
        except Exception as e:
            return f"Error searching for folders: {str(e)}"

}")
            return "ERROR_ASSESSING"
            
        return "SAFE"
    
    def get_usb_devices(self):
        """
        Get a list of available USB devices.
        
        Returns:
            str: Formatted string with device information
        """
        return self.usb_detector.get_usb_devices()
    
    