"""
Shell command handling for UaiBot in a modular structure.
This version removes the send_to_screen_session method and uses the ScreenManager instead.
"""
import subprocess
import shlex
import os
import platform
import json
from core.utils import get_platform_name
from device_manager.usb_detector import USBDetector

try:
    from core.platform_commands import get_platform_command
except ImportError:
    # Define a placeholder if the module is not available
    def get_platform_command(platform, command_type, subtype=None):
        return None

# Basic list of commands that are generally safe.
SAFE_COMMAND_WHITELIST = [
    # Basic navigation and file operations
    'ls', 'cd', 'pwd', 'echo', 'cat', 'mkdir', 'rmdir', 'cp', 'mv', 'find', 'grep',
    # Programming and development tools
    'python', 'python3', 'pip', 'git', 'man', 'uname',
    # System information and management
    'df', 'du', 'free', 'top', 'ps', 'kill', 'killall', 'uptime', 'cal', 'date',
    # macOS specific commands
    'osascript', 'screen', 'open', 'softwareupdate', 'caffeinate', 'say',
    # Text editors and viewers
    'nano', 'vi', 'vim', 'less', 'more', 'head', 'tail',
    # Network tools
    'ping', 'curl', 'wget', 'ssh', 'scp', 'telnet', 'netstat', 'ifconfig', 'traceroute', 'nslookup',
    # Text processing
    'grep', 'awk', 'sed', 'sort', 'uniq', 'wc', 'diff', 'pbcopy', 'pbpaste',
    # File management
    'touch', 'ditto', 'chmod', 'chown', 'chgrp', 'ln',
    # System commands
    'history', 'crontab', 'alias', 'which', 'whereis', 'whoami', 'who', 'w', 
    # Advanced macOS commands
    'networksetup', 'airport', 'scutil', 'mdfind', 'diskutil', 'system_profiler', 
    'sw_vers', 'sysctl', 'pmset', 'launchctl', 'defaults', 'plutil', 'hdiutil', 
    'screencapture', 'security', 'xcode-select', 'xcodebuild', 'xcrun', 'codesign', 
    'spctl', 'ioreg', 'pkgutil', 'automator', 'afplay'
]

# Commands that should always require confirmation or be blocked in certain modes.
POTENTIALLY_DANGEROUS_COMMANDS = [
    'rm', 'sudo', 'mkfs', 'shutdown', 'reboot', 'dd', 'fdisk', 'kill', 
    'chmod', 'chown', 'chgrp', 'mv', 'cp', 'rmdir', 'ln -s', 'format',
    'diskutil', 'diskpart', 'parted', 'gparted', '> /dev/', '| sudo', 
    'mkfs', 'fsck', 'mount', 'umount', ':(){', 'eval', 'dmesg'
]

class ShellHandler:
    def __init__(self, safe_mode=True, enable_dangerous_command_check=True, suppress_prompt=False, quiet_mode=False):
        """
        Initializes the ShellHandler.
        Args:
            safe_mode (bool): If True, restricts execution to whitelisted commands.
            enable_dangerous_command_check (bool): If True, checks commands against POTENTIALLY_DANGEROUS_COMMANDS.
            suppress_prompt (bool): If True, does not prompt for confirmation.
            quiet_mode (bool): If True, reduces unnecessary terminal output.
        """
        self.safe_mode = safe_mode
        self.enable_dangerous_command_check = enable_dangerous_command_check
        self.suppress_prompt = suppress_prompt
        self.quiet_mode = quiet_mode
        self.system_platform = platform.system().lower()
        self.platform_name = get_platform_name()
        
        # Will be assigned externally
        self.screen_manager = None
        
        # Create a USB device detector
        self.usb_detector = USBDetector(quiet_mode=quiet_mode)
        
        if not self.quiet_mode:
            print(f"ShellHandler initialized. Safe mode: {self.safe_mode}, Dangerous command check: {self.enable_dangerous_command_check}")
    
    def log(self, message):
        """Print a message if not in quiet mode"""
        if not self.quiet_mode:
            print(message)
    
    # Update safe commands for the current platform
    def _update_safe_commands_for_platform(self):
        """Update safe commands list with platform-specific commands"""
        # Platform-specific commands are already included in the whitelist
        pass
    
    def _is_command_safe(self, command_parts):
        """Checks if the command is on the whitelist."""
        if not command_parts:
            return False
        command_name = command_parts[0]

        # Add platform-specific commands to the safe list
        self._update_safe_commands_for_platform()
        
        if command_name in SAFE_COMMAND_WHITELIST:
            return True
        
        # Basic check for path-like commands (e.g. /bin/ls)
        if '/' in command_name and command_name.split('/')[-1] in SAFE_COMMAND_WHITELIST:
            return True

        return False

    def _is_potentially_dangerous(self, command_parts):
        """Checks if the command is in the list of potentially dangerous commands."""
        if not command_parts:
            return False
        command_name = command_parts[0]
        
        if command_name in POTENTIALLY_DANGEROUS_COMMANDS:
            return True
        # Check for sudo usage with another command
        if command_name == 'sudo' and len(command_parts) > 1 and command_parts[1] in POTENTIALLY_DANGEROUS_COMMANDS:
            return True
        return False
    
    def _fix_platform_command(self, command_string):
        """Adjust command based on platform if needed"""
        # Simple pass-through for now, can be extended in the future
        return command_string
    
    def execute_command(self, command_string, force_shell=False, require_confirmation_for_shell=True):
        """Execute a shell command and return the output"""
        try:
            # Clean up the command string
            command_string = command_string.strip()
            
            # Remove markdown code block markers and backticks
            if command_string.startswith('```'):
                while command_string.startswith('`'):
                    command_string = command_string[1:]
                end_pos = command_string.rfind('```')
                if end_pos != -1:
                    command_string = command_string[:end_pos]
            elif command_string.startswith('`') and command_string.endswith('`'):
                command_string = command_string[1:-1]
                
            # Remove language hints from the start
            first_line_end = command_string.find('\n')
            if first_line_end != -1:
                first_line = command_string[:first_line_end].strip().lower()
                if first_line in ['bash', 'shell', 'zsh', 'sh', 'cmd', 'powershell']:
                    command_string = command_string[first_line_end + 1:]
            
            # Remove any remaining backticks
            command_string = command_string.replace('`', '').strip()
            
            if not command_string.strip():
                return "Error: No command provided after processing."

            # Check for and fix platform-specific commands
            command_string = self._fix_platform_command(command_string)
            self.log(f"Attempting to execute: {command_string}")

            # Special handling for commands that need shell=True
            if ('*' in command_string or '?' in command_string or 
                '|' in command_string or '>' in command_string or 
                '<' in command_string or ';' in command_string or  
                '&&' in command_string or '`' in command_string or '$(' in command_string):
                self.log(f"Using shell=True for command with special syntax: {command_string}")
                force_shell = True

            # Special handling for device path commands
            if (command_string.startswith('ls /dev') or 
                any(cmd in command_string for cmd in ['screen /dev', 'cat /dev', 'echo > /dev', 'stty -f /dev'])):
                self.log(f"Using shell=True for command with device paths: {command_string}")
                force_shell = True

            # Special handling for screen command
            if command_string.startswith('screen '):
                self.log("Using special handling for screen command")
                return subprocess.run(command_string, text=True, shell=True, 
                                     stdout=subprocess.PIPE, stderr=subprocess.PIPE).stderr or "Screen command executed"
                
            # Special handling for USB device queries
            if ('usb' in command_string.lower() or 'dev/tty' in command_string.lower() or 'dev/cu' in command_string.lower()) and \
               any(cmd in command_string.lower() for cmd in ['list', 'show', 'check', 'find']):
                self.log("Using USB detector for device query")
                return self.usb_detector.get_usb_devices()
                
            # Special handling for 'cd' command
            if command_string.strip().startswith('cd '):
                parts = shlex.split(command_string)
                if len(parts) > 1:
                    path_to_change = os.path.expanduser(parts[1])
                    try:
                        os.chdir(path_to_change)
                        return f"Changed directory to {os.getcwd()}"
                    except Exception as e:
                        return f"Error changing directory: {str(e)}"
                else: # just 'cd' often means go to home directory
                    try:
                        home_dir = os.path.expanduser('~')
                        os.chdir(home_dir)
                        return f"Changed directory to {os.getcwd()}"
                    except Exception as e:
                        return f"Error changing to home directory: {str(e)}"

            # Execute command
            if not force_shell:
                try:
                    # Split command and execute
                    command_parts = shlex.split(command_string)
                    if not command_parts:
                        return "Error: Command is empty after parsing."

                    command_name = command_parts[0]

                    if self.safe_mode and not self._is_command_safe(command_parts):
                        return f"Error: Command '{command_name}' is not in the allowed list in safe mode."

                    if self.enable_dangerous_command_check and self._is_potentially_dangerous(command_parts):
                        if self.safe_mode:
                            return f"Error: Execution of potentially dangerous command '{command_string}' blocked in safe mode."
                        self.log(f"Warning: Command '{command_string}' is potentially dangerous.")

                    # Execute without shell=True
                    self.log(f"Executing with shlex: {command_parts}")
                    result = subprocess.run(command_parts, capture_output=True, text=True, check=False)
                except ValueError as e:
                    # If shlex can't parse the command, try with shell=True if permitted
                    self.log(f"Error parsing command with shlex: {str(e)}")
                    if not self.safe_mode or force_shell:
                        self.log(f"Falling back to shell=True for: {command_string}")
                        result = subprocess.run(command_string, shell=True, capture_output=True, text=True, check=False)
                    else:
                        return f"Error: Could not parse command '{command_string}'. Try simplifying or using quotes properly."
            else: # force_shell is True
                if require_confirmation_for_shell and not self.suppress_prompt and self.safe_mode:
                    self.log(f"Warning: Executing command '{command_string}' with shell=True.")
                    if self.safe_mode:
                        self.log("Shell=True allowed without confirmation due to special command needs.")
                
                self.log(f"Executing with shell=True: {command_string}")
                result = subprocess.run(command_string, shell=True, capture_output=True, text=True, check=False)

            # Process command output
            if result.returncode != 0:
                error_message = f"Error executing command: {command_string}"
                error_message += f"\nReturn Code: {result.returncode}"
                if result.stdout:
                    error_message += f"\nStdout:\n{result.stdout.strip()}"
                if result.stderr:
                    error_message += f"\nStderr:\n{result.stderr.strip()}"
                self.log(error_message)
                return result.stderr.strip() if result.stderr else f"Command failed with return code {result.returncode}"
            return result.stdout.strip()
        
        except Exception as e:
            return f"An unexpected error occurred: {str(e)}"
    
    def send_to_screen_session(self, command, device_path=None):
        """
        Forward to the screen manager for sending commands to a screen session.
        This maintains backward compatibility with code that calls this method.
        
        Args:
            command (str): Command to send
            device_path (str, optional): Device path to look for in session names
            
        Returns:
            str: Result message
        """
        if self.screen_manager:
            return self.screen_manager.send_command_to_session(command, device_path=device_path)
        else:
            return "Screen manager not initialized. Cannot send command to screen session."
    
    def detect_command_target(self, command, context=""):
        """
        Determine if a command should go to the screen session or local system.
        
        Args:
            command (str): The command to analyze
            context (str): Additional context text that might hint at target
            
        Returns:
            str: "SCREEN", "LOCAL", or "UNKNOWN"
        """
        # If explicit screen indicators in context, prefer screen
        screen_indicators = [
            "screen", "serial", "usb", "terminal session", "device", 
            "remote", "remote system", "remote machine", "other os", 
            "other machine", "screened", "over usb", "over the usb", 
            "connected device", "through screen"
        ]
        
        if any(indicator in context.lower() for indicator in screen_indicators):
            return "SCREEN"
            
        # Check if command is a direct file/navigation command
        nav_commands = ['ls', 'pwd', 'cd', 'dir']
        sys_commands = ['top', 'ps', 'df', 'du', 'uptime', 'date', 'whoami', 'who']
        
        # Split the command to get the base command
        command_parts = command.split()
        base_command = command_parts[0] if command_parts else ""
        
        # Navigation commands with no args are ambiguous
        if base_command in nav_commands and len(command_parts) == 1:
            # Check if we have a USB/serial context
            if any(term in context.lower() for term in ["usb", "serial", "device", "screen"]):
                return "SCREEN"
            else:
                return "LOCAL"
                
        # System information commands typically run locally
        if base_command in sys_commands:
            return "LOCAL"
            
        # Mac-specific commands almost always run locally
        mac_commands = ['open', 'say', 'pbcopy', 'pbpaste', 'networksetup', 'airport',
                        'system_profiler', 'sw_vers', 'defaults', 'osascript']
        if base_command in mac_commands:
            return "LOCAL"
            
        # If we can't determine, default to LOCAL for safety
        return "LOCAL"
    
    def check_command_safety_level(self, command_string):
        """
        Checks the safety level of a command string.
        
        Returns:
            str: Safety level
        """
        try:
            # Quick pass to see if command is empty
            if not command_string or not command_string.strip():
                return "EMPTY"
                
            # Check for special characters that might need shell=True
            contains_wildcards = '*' in command_string or '?' in command_string
            special_operators = ['|', '>', '<', ';', '&&', '||', '`', '$(']
            contains_special = any(op in command_string for op in special_operators)
            
            if contains_wildcards or contains_special:
                return "REQUIRES_SHELL_TRUE_ASSESSMENT"
            
            # Parse command with shlex
            try:
                command_parts = shlex.split(command_string)
                if not command_parts:
                    return "EMPTY"
                    
                # Check against our safe and dangerous lists
                if self._is_command_safe(command_parts):
                    if self._is_potentially_dangerous(command_parts):
                        return "POTENTIALLY_DANGEROUS"
                    else:
                        return "SAFE"
                else:
                    return "NOT_IN_WHITELIST"
                    
            except ValueError:
                return "REQUIRES_SHELL_TRUE_ASSESSMENT"
                
        except Exception as e:
            self.log(f"Error in check_command_safety_level: {str(e)}")
            return "ERROR_ASSESSING"
            
        return "SAFE"
    
    def get_usb_devices(self):
        """
        Get a list of available USB devices.
        
        Returns:
            str: Formatted string with device information
        """
        return self.usb_detector.get_usb_devices()
