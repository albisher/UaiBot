# Redirect stderr to suppress warnings before any imports
import sys
import os
import argparse

# Check for quiet mode early to suppress warnings
if '-q' in sys.argv or '--quiet' in sys.argv:
    sys.stderr = open(os.devnull, 'w')

import json
import re
import subprocess
from core.ai_handler import AIHandler
from core.shell_handler import ShellHandler
from core.utils import load_config, get_project_root
from core.command_help import CommandHelp
from platform_uai.platform_manager import PlatformManager
        
        # If remote system terms were used and asking about USB devices
        if any(indicator in query_lower for indicator in remote_system_indicators) and screen_exists:
            if any(term in query_lower for term in ["usb", "device", "serial", "port", "connected"]):
                # This is likely asking about USB devices on remote system
                print(f"Checking for USB devices on remote system...")
                cmd = "ls -l /dev/tty* /dev/cu.* 2>/dev/null || ls -l /dev/ttyUSB* /dev/ttyACM* 2>/dev/null"
                result = shell_handler.send_to_screen_session(cmd)
                print(result)
                return
        
        # If we still haven't found a command match, check if user specifically mentioned common commands
        command_match = None
        
        for pattern in patterns:
            match = re.search(pattern, query_lower)
            if match:_root
from core.command_help import CommandHelp
from platform_uai.platform_manager import PlatformManager

def is_natural_language_query(query_lower):
    """
    Detects if a user input is likely a natural language query rather than a direct command.
    Returns True if it looks like natural language that should go to the AI.
    """
    # System information query patterns
    system_info_patterns = [
        r'(how|show|tell|what|display).*?(system|uptime|disk|space|storage|memory|cpu)',
        r'(how long|uptime|running time|system uptime|been up|been running)',
        r'(disk|space|storage|memory|cpu|processor).*(usage|free|available)',
        r'(show|display|list|get).*(system|process|network|running|active)',
        r'(what|how).*(file|directory|folder|path)',
    ]
    
    # If it matches any of the patterns, it's likely a natural language query
    if any(re.search(pattern, query_lower) for pattern in system_info_patterns):
        return True
        
    # If it starts with question words or action verbs not typically used in commands
    question_starters = ['how', 'what', 'when', 'why', 'where', 'who', 'can', 'could', 'please', 'would']
    if any(query_lower.startswith(word) for word in question_starters):
        return True
        
    # If it's a full English sentence (rough heuristic)
    if len(query_lower.split()) > 3 and not query_lower.startswith(('ls', 'cd', 'rm', 'cp', 'mv', 'sudo')):
        return True
        
    return False

# Create a special function to handle natural language screen file commands
def extract_screen_command(query):
    """
    Helper function to extract the appropriate command for common screen-related natural language queries
    """
    query_lower = query.lower()
    
    # File operations
    if any(term in query_lower for term in ["show me files", "list files", "list the files", "show the files", "show files", "what files"]):
        return "ls -la"
    elif any(term in query_lower for term in ["disk usage", "disk space", "storage space", "available space"]):
        return "df -h"
    elif any(term in query_lower for term in ["current directory", "where am i", "which directory", "what directory", "what folder"]):
        return "pwd"
    
    # Process monitoring
    elif any(term in query_lower for term in ["process", "running process", "what's running", "running tasks", "show processes"]):
        return "ps aux | head -20"
    
    # System information
    elif any(term in query_lower for term in ["system info", "system information", "os version", "operating system"]):
        return "uname -a && cat /etc/*release 2>/dev/null || sw_vers"
    elif any(term in query_lower for term in ["uptime", "how long", "system uptime", "been up", "been running"]):
        return "uptime"
    
    # USB/Serial specific - Enhanced with multiple detection methods for better compatibility
    elif any(term in query_lower for term in ["usb devices", "connected devices", "list devices", "show devices", 
                                             "remote devices", "remote usb", "screen devices", "devices on screen"]):
        # More comprehensive command that works on Linux, macOS and handles remote systems better
        return "ls -l /dev/cu.* /dev/tty.* 2>/dev/null || ls -l /dev/ttyUSB* /dev/ttyACM* 2>/dev/null || dmesg | grep -i 'usb'"
    elif any(term in query_lower for term in ["serial port", "port info", "connected ports"]):
        return "ls -l /dev/cu.* /dev/tty.* 2>/dev/null || ls -l /dev/ttyUSB* /dev/ttyACM* 2>/dev/null"
    
    # Network information
    elif any(term in query_lower for term in ["network", "ip address", "show ip", "my ip"]):
        return "ifconfig | grep 'inet ' | grep -v 127.0.0.1"
    
    return None
        
def process_command(user_input, ai_handler, shell_handler):
    """
    Processes a single user command, determining whether it should be executed
    locally or sent to a screen session. Handles a wide range of command patterns
    including all categories from enhancements2.txt.
    """
    if not user_input.strip():
        print("Please enter a command.")
    query_lower = user_input.lower()
    user_input_orig = user_input  # Save original input with proper case
    
    # ==========================================
    # STEP 0: First check if this is a help request - these should ALWAYS be processed locally
    # ==========================================
    help_keywords = ['help', 'how to', 'usage', 'manual', 'man', 'info', 'examples', 'explain']
    if any(keyword in query_lower for keyword in help_keywords) and not query_lower.startswith(('send', 'run')):
        is_help_request = True
        
        import re
        # Check if any known command is mentioned
        for command in CommandHelp.list_available_commands():
            # Look for the command as a standalone word
            pattern = rf'\b{re.escape(command)}\b'
            if re.search(pattern, query_lower):
                # Found a command help request
                help_info = CommandHelp.get_command_help(command)
                if help_info:
                    print(f"\n======= Help: {command} =======")
                    print(f"Description: {help_info['description']}")
                    print(f"Syntax: {help_info['syntax']}")
                    print("\nExamples:")
                    for example in help_info['examples']:
                        print(f"  {example}")
                    print(f"Categories: {', '.join(help_info['categories'])}")
                    print("=============================\n")
                    return
        
        # If they asked for help with a category
        for category in ['file', 'directory', 'system', 'network', 'text', 'editor', 'automation']:
            if category in query_lower:
                commands = CommandHelp.get_command_category(category)
                if commands:
                    print(f"\n======= Commands in '{category}' category =======")
                    for cmd in commands:
                        help_info = CommandHelp.get_command_help(cmd)
                        print(f"- {cmd}: {help_info['description']}")
                    print("\nFor detailed help on a specific command, type 'help [command]'")
                    print("=========================================\n")
                    return
    
    # Check if there's a current screen context
    # This function sets a context flag to help decide where commands should go by default
    screen_exists = False
    try:
        result = subprocess.run(['screen', '-ls'], capture_output=True, text=True)
        screen_output = result.stdout + result.stderr
        if "No Sockets found" not in screen_output:
            screen_exists = True
    except Exception:
        screen_exists = False
    
    # ==========================================
    # STEP 1: First check for explicit screen session command indicators
    # ==========================================
    screen_session_indicators = [
        "screen session", "serial port", "usb terminal", "in screen", "on screen", 
        "to screen", "through screen", "via screen", "in the screen", "on the screen",
        "in terminal session", "in the terminal session", "over serial", "usb screen",
        "connected screen", "usb connected", "serial screen", "connected usb", "connected serial",
        "device screen", "connected device"
    ]
    
    explicitly_screen = any(indicator in query_lower for indicator in screen_session_indicators)
    
    # ==========================================
    # STEP 2: Check for commands that INITIATE screen sessions
    # ==========================================
    if query_lower.startswith("screen ") and any(term in query_lower for term in ['dev', 'cu', 'tty', 'serial', 'usb']):
        # This is likely a command to open a new screen session with a device
        cmd = shell_handler.execute_command(user_input_orig)
        print(cmd)
        return
    
    # ==========================================
    # STEP 3: Check for EXPLICIT send patterns
    # ==========================================
    if any(query_lower.startswith(prefix) for prefix in ["send ", "run ", "execute ", "type "]):
        # Direct command passing through "send" or similar patterns
        import re
        for prefix in ["send ", "run ", "execute ", "type "]:
            if query_lower.startswith(prefix):
                remaining_cmd = user_input_orig.split(" ", 1)[1].strip()
                
                # Check for patterns like "send ls to screen" or "send command ls to screen"
                screen_pattern = re.search(r'^(.*?)\s+(?:to|on|in)\s+(?:the\s+)?(?:screen|terminal|session|serial)$', remaining_cmd, re.IGNORECASE)
                command_pattern = re.search(r'^command\s+[\'"]?(.*?)[\'"]?$', remaining_cmd, re.IGNORECASE)
                
                # Extract the actual command to send
                direct_cmd = remaining_cmd
                if screen_pattern:
                    direct_cmd = screen_pattern.group(1).strip()
                    # If it starts with "command" and possibly has quotes, extract the actual command
                    command_match = re.search(r'^command\s+[\'"]?(.*?)[\'"]?$', direct_cmd, re.IGNORECASE)
                    if command_match:
                        direct_cmd = command_match.group(1).strip()
                
                if direct_cmd:
                    if any(term in query_lower for term in ["screen", "terminal", "session", "serial"]):
                        # Explicit target is screen
                        print(f"Sending command '{direct_cmd}' to active screen session...")
                        result = shell_handler.send_to_screen_session(direct_cmd)
                        print(result)
                        return
                    elif screen_exists:
                        # No explicit target but screen exists, ask for confirmation
                        print(f"Would you like to send '{direct_cmd}' to the screen session? (y/n)")
                        response = input().strip().lower()
                        if response == 'y' or response == 'yes':
                            print(f"Sending command '{direct_cmd}' to active screen session...")
                            result = shell_handler.send_to_screen_session(direct_cmd)
                            print(result)
                            return
                        else:
                            # Execute locally
                            print(f"Executing command locally: '{direct_cmd}'")
                            cmd = shell_handler.execute_command(direct_cmd)
                            print(cmd)
                            return
                    else:
                        # No screen exists, run locally
                        print(f"Executing command locally: '{direct_cmd}'")
                        cmd = shell_handler.execute_command(direct_cmd)
                        print(cmd)
                        return
    
    # ==========================================
    # STEP 4: Handle DIRECT TERMINAL COMMANDS
    # ==========================================
    
    # Comprehensive list of all terminal commands from enhancements2.txt
    common_commands = [
        # File & directory operations
        'ls', 'pwd', 'cd', 'mkdir', 'rmdir', 'cp', 'mv', 'rm', 'touch', 'cat', 'find',
        # Text viewing/editing
        'more', 'less', 'head', 'tail', 'nano', 'vi', 'vim', 'grep', 'awk', 'sed',
        # System info
        'top', 'ps', 'kill', 'killall', 'df', 'du', 'free', 'uptime', 'date', 'cal', 'who', 'whoami',
        # Networking
        'ping', 'curl', 'wget', 'ssh', 'scp', 'ifconfig', 'netstat', 'traceroute', 'nslookup',
        # macOS specific
        'open', 'pbcopy', 'pbpaste', 'say', 'ditto', 'mdfind', 'diskutil',
        # Miscellaneous
        'echo', 'history', 'man', 'clear', 'alias', 'crontab'
    ]
    
    # Direct command with no args - check if it's a common terminal command
    command_base = query_lower.split()[0] if ' ' in query_lower else query_lower
    
    if command_base in common_commands and not query_lower.startswith(('make', 'tell', 'have')):
        # It's a direct command (e.g. "ls -la" or "pwd")
        
        # INTERACTIVE COMMANDS - more caution with screen sessions
        interactive_commands = ['nano', 'vi', 'vim', 'less', 'more', 'top', 'man']
        is_interactive = command_base in interactive_commands
        
        # If the command has arguments or it's an interactive command
        if ' ' in query_lower or is_interactive:
            if explicitly_screen or any(term in query_lower for term in ["usb", "serial", "connected", "device"]):
                # User explicitly mentioned screen/usb/serial/connected device
                device_desc = "screen session"
                if "usb" in query_lower:
                    device_desc = "USB device"
                elif "serial" in query_lower:
                    device_desc = "serial connection"
                elif "connected" in query_lower or "device" in query_lower:
                    device_desc = "connected device"
                    
                print(f"Sending command '{user_input_orig}' to active {device_desc}...")
                result = shell_handler.send_to_screen_session(user_input_orig)
                print(result)
                return
            elif screen_exists:
                # For interactive commands, ask first since they require more interaction
                if is_interactive:
                    print(f"'{command_base}' is an interactive command. Send to screen session? (y/n)")
                    response = input().strip().lower()
                    if response == 'y' or response == 'yes':
                        print(f"Sending interactive command '{user_input_orig}' to active screen session...")
                        result = shell_handler.send_to_screen_session(user_input_orig)
                        print(result)
                        return
                
                # For non-interactive or user declined sending interactive command to screen
                print(f"Executing command locally: '{user_input_orig}'")
                cmd = shell_handler.execute_command(user_input_orig)
                print(cmd)
                return
            else:
                # No screen exists, run locally
                print(f"Executing command locally: '{user_input_orig}'")
                cmd = shell_handler.execute_command(user_input_orig)
                print(cmd)
                return
        else:
            # Simple command with no args, like just "ls" or "pwd"
            if explicitly_screen:
                # User explicitly mentioned screen
                print(f"Sending command '{user_input_orig}' to active screen session...")
                result = shell_handler.send_to_screen_session(user_input_orig)
                print(result)
                return
            elif screen_exists:
                # Screen exists but user didn't specify, give preference to screen for simple navigation commands
                navigation_commands = ['ls', 'pwd', 'cd', 'clear']
                if command_base in navigation_commands:
                    print(f"Sending command '{user_input_orig}' to active screen session...")
                    result = shell_handler.send_to_screen_session(user_input_orig)
                    print(result)
                    return
                else:
                    # For other commands, run locally by default
                    print(f"Executing command locally: '{user_input_orig}'")
                    cmd = shell_handler.execute_command(user_input_orig)
                    print(cmd)
                    return
            else:
                # No screen exists, run locally
                print(f"Executing command locally: '{user_input_orig}'")
                cmd = shell_handler.execute_command(user_input_orig)
                print(cmd)
                return
    
    # ==========================================
    # STEP 5: Check for complex command PATTERNS
    # ==========================================
    
    # Cases like "make it do X" or "tell screen to do X"
    import re
    command_match = None
    
    # Special handling for common natural language screen commands
    if screen_exists and any(term in query_lower for term in ["screen", "usb", "serial", "device", "connected"]):
        # Try to extract natural language command
        extracted_cmd = extract_screen_command(user_input_orig)
        if extracted_cmd:
            print(f"Sending command '{extracted_cmd}' to active screen session...")
            result = shell_handler.send_to_screen_session(extracted_cmd)
            print(result)
            return
        
    # If it's a phrase like "make it do ls" or "make screen do ls" or other variants
    explicit_screen_patterns = ['make it', 'tell it', 'have it', 'make screen', 'tell screen', 'tell the screen', 
                              'on screen', 'in screen', 'screen to', 'to the screen', 'via screen', 'through screen',
                              'usb screen', 'connected screen', 'usb connected', 'connected usb', 'serial screen', 
                              'device screen', 'connected device', 'on the usb', 'on the serial', 'on the connected',
                              'screened os', 'remote device', 'remote os', 'over usb connection', 'over my usb',
                              'over the usb', 'remote system', 'remote machine', 'other os', 'other machine']
    if any(pattern in query_lower for pattern in explicit_screen_patterns):
        # Let's handle the special case first for "tell the screen to show me the files"
        # or similar natural language patterns
        if "show me the files" in query_lower or "list the files" in query_lower:
            command_match = "ls -la"
        
        patterns = [
            r'(?:make|tell|have)\s+(?:it|the\s+)?(?:screen|terminal|session)\s+(?:do|run|execute|type)\s+[\'"]?([\w\s\-\.\/\*\>\<\|\&]+)[\'"]?',  # make it do X
            r'(?:in|on|at)\s+(?:the\s+)?(?:screen|terminal|session).*?(?:do|run|execute|type)\s+[\'"]?([\w\s\-\.\/\*\>\<\|\&]+)[\'"]',  # on screen do X
            r'(?:send|run|do|execute|type)\s+[\'"]?([\w\s\-\.\/\*\>\<\|\&]+)[\'"]?\s+(?:to|in|on|at)\s+(?:the\s+)?(?:screen|terminal|session)',  # send X to screen
            r'(?:tell|ask)\s+(?:the\s+)?(?:screen|terminal|session)\s+to\s+(?:do|run|execute|type|show|list|display)\s+[\'"]?([\w\s\-\.\/\*\>\<\|\&]+)[\'"]?',  # tell screen to do X
            r'(?:screen|terminal|session).*?(?:should|must|please)?\s+(?:show|list|display|run)\s+[\'"]?([\w\s\-\.\/\*\>\<\|\&]+)[\'"]?',  # screen show X
        ]
        
        for pattern in patterns:
            match = re.search(pattern, query_lower)
            if match:
                command_match = match.group(1).strip()
                break
        
        if command_match:
            print(f"Sending command '{command_match}' to active screen session...")
            result = shell_handler.send_to_screen_session(command_match)
            print(result)
            return
        
        # Fallback for simple commands if no complex pattern matched
        for cmd in common_commands:
            if cmd in query_lower and any(term in query_lower for term in ['screen', 'terminal', 'session', 'serial']):
                print(f"Sending command '{cmd}' to active screen session...")
                result = shell_handler.send_to_screen_session(cmd)
                print(result)
                return
    
    # ==========================================
    # STEP 6: Check for other screen-related patterns
    # ==========================================
    
    # Handle other phrasings related to screen/terminal/session/usb
    if ('screen' in query_lower and any(term in query_lower for term in ['send', 'run', 'do', 'execute', 'type', 'command', 'show', 'list', 'display'])) or \
       ('terminal' in query_lower and any(term in query_lower for term in ['screen', 'session', 'send', 'command', 'connected'])) or \
       ('serial' in query_lower and any(term in query_lower for term in ['command', 'send', 'type', 'list', 'show', 'connected'])) or \
       ('usb' in query_lower and any(term in query_lower for term in ['command', 'terminal', 'screen', 'connected', 'device'])) or \
       ('connected' in query_lower and any(term in query_lower for term in ['device', 'screen', 'serial', 'usb', 'port'])) or \
       ('device' in query_lower and any(term in query_lower for term in ['screen', 'connected', 'serial', 'usb', 'port'])):
        
        # Try to extract the command using various patterns
        patterns = [
            r'(?:send|run|do|execute|type)\s+[\'"]?([\w\s\-\.\/\*]+)[\'"]?\s+(?:to|in|on|at)\s+(?:the\s+)?(?:screen|terminal|session)',  # send X to screen
            r'(?:screen|terminal|session).*?(?:do|run|execute|type)\s+[\'"]?([\w\s\-\.\/\*]+)[\'"]',  # make screen do X
            r'(?:in|on|at)\s+(?:the\s+)?(?:screen|terminal|session).*?(?:do|run|execute|type)\s+[\'"]?([\w\s\-\.\/\*]+)[\'"]',  # on screen do X
            r'(?:send|run|do|execute|type).*?[\'"]?([\w\s\-\.\/\*]+)[\'"]',  # generic fallback - try to find command after action words
        ]
        
        # If we still haven't found a command, check if user specifically mentioned common commands
        command_match = None
        
        for pattern in patterns:
            match = re.search(pattern, query_lower)
            if match:
                command_match = match.group(1).strip()
                break
        
        if not command_match:
            for cmd in common_commands:
                standalone_cmd_pattern = rf'\b{cmd}\b'
                if re.search(standalone_cmd_pattern, query_lower):
                    command_match = cmd
                    break
                
        # If we found a command, try to send it to the screen session
        if command_match:
            print(f"Sending command '{command_match}' to active screen session...")
            result = shell_handler.send_to_screen_session(command_match)
            print(result)
            return
    
    # ==========================================
    # STEP 6.5: Enhanced remote system/screen detection
    # ==========================================
    
    # Check for remote system related queries 
    remote_system_indicators = [
        "screened os", "remote device", "remote os", "remote system", 
        "remote machine", "other os", "other machine", "over usb connection", 
        "over my usb", "over the usb", "through screen", "in screen session",
        "other system", "screened system", "connected system", "device usb"
    ]
    
    # If remote system terms were used and asking about USB devices
    if any(indicator in query_lower for indicator in remote_system_indicators) and screen_exists:
        if any(term in query_lower for term in ["usb", "device", "serial", "port", "connected"]):
            # This is likely asking about USB devices on remote system
            if not shell_handler.quiet_mode:
                print(f"Checking for USB devices on remote system...")
            
            # Choose the appropriate command based on the context
            device_cmd = None
            if "list" in query_lower or "show" in query_lower:
                # More detailed listing of devices requested
                device_cmd = "ls -l /dev/tty* /dev/cu.* 2>/dev/null || ls -l /dev/ttyUSB* /dev/ttyACM* 2>/dev/null"
            elif "dmesg" in query_lower or "logs" in query_lower:
                # Get USB-related system logs
                device_cmd = "dmesg | grep -i usb | tail -20"
            else:
                # Default command - comprehensive detection that works on most systems
                device_cmd = "echo 'ðŸ“± USB Devices on Remote System:' && echo '' && " + \
                             "ls -l /dev/tty* /dev/cu.* 2>/dev/null || ls -l /dev/ttyUSB* /dev/ttyACM* 2>/dev/null && " + \
                             "echo '' && echo 'ðŸ” USB Hardware Information:' && echo '' && " + \
                             "lsusb 2>/dev/null || system_profiler SPUSBDataType 2>/dev/null || dmesg | grep -i usb | tail -10"
            
            result = shell_handler.send_to_screen_session(device_cmd)
            print(result)
            return
    
    # ==========================================
    # STEP 7: Special handling for certain command types
    # ==========================================
    
    # Special handling for analyzing Wi-Fi speed
    if any(k in query_lower for k in ['wifi speed', 'internet speed', 'speed test']):
        import platform, subprocess, re
        system_platform = platform.system().lower()
        print("Retrieving Wi-Fi link speed...")
        if system_platform == 'darwin':
            try:
                # First try Apple's airport utility
                airport = "/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport"
                try:
                    out = subprocess.check_output([airport, "-I"], text=True)
                    m = re.search(r"lastTxRate: (\d+)", out)
                    if m:
                        print(f"Wi-Fi link speed: {m.group(1)} Mbps")
                    else:
                        # Fallback to networksetup command
                        out = subprocess.check_output(["networksetup", "-getinfo", "Wi-Fi"], text=True)
                        print(f"Wi-Fi connection info:\n{out}")
                except Exception:
                    # Fallback to system_profiler
                    out = subprocess.check_output(["system_profiler", "SPNetworkDataType"], text=True)
                    wifi_section = re.search(r"Wi-Fi:.*?(?=^\S)", out, re.MULTILINE | re.DOTALL)
                    if wifi_section:
                        print(f"Wi-Fi connection details:\n{wifi_section.group(0).strip()}")
                    else:
                        print("Could not determine Wi-Fi details.")
            except Exception as e:
                print(f"Error retrieving Wi-Fi speed: {e}")
        elif system_platform in ['linux', 'ubuntu', 'jetson']:
            try:
                out = subprocess.check_output(["iwconfig"], stderr=subprocess.DEVNULL, text=True)
                m = re.search(r"Bit Rate=(\d+\.?\d*) Mb/s", out)
                print(f"Wi-Fi link speed: {m.group(1)} Mbps" if m else "Could not determine Wi-Fi link speed.")
            except Exception:
                print("Error: 'iwconfig' command not available or failed.")
        else:
            print("Error: Unsupported platform for Wi-Fi speed retrieval.")
        return
    
    # ==========================================
    # STEP 8: Handle USB device commands that aren't explicit screen commands
    # ==========================================
    
    # Check for USB device mentions without explicit screen command patterns
    if any(term in query_lower for term in ['usb', 'serial', 'tty', 'dev/cu', 'dev/tty', 'connected device', 'port', 'usb screen', 'connected screen']):
        # This is likely a USB device operation, try to extract a command
        device_command_patterns = [
            r'(?:on|to|with|in|at|via|through)\s+(?:the\s+)?(?:usb|serial|device|port|connection).*?(?:do|run|execute|type|send|show|list|display)\s+[\'"]?([\w\s\-\.\/\*\>\<\|\&]+)[\'"]',  # on usb do X
            r'(?:do|run|execute|type|send|show|list|display)\s+[\'"]?([\w\s\-\.\/\*\>\<\|\&]+)[\'"].*?(?:on|to|with|in|at|via|through)\s+(?:the\s+)?(?:usb|serial|device|port|connection)',  # do X on usb
            r'(?:usb|serial|device|port|connection).*?(?:should|could|must|please)?\s+(?:do|run|execute|type|send|show|list|display)\s+[\'"]?([\w\s\-\.\/\*\>\<\|\&]+)[\'"]',  # usb show X
        ]
        
        for pattern in device_command_patterns:
            match = re.search(pattern, query_lower)
            if match:
                command_match = match.group(1).strip()
                print(f"Sending command '{command_match}' to active USB/screen session...")
                result = shell_handler.send_to_screen_session(command_match)
                print(result)
                return
        
        # Special handling for USB device detection commands
        if any(term in query_lower for term in ["list devices", "show devices", "connected usb", "check usb", "find usb",
                                              "list usb", "detect usb", "show connected", "what usb", "usb devices",
                                              "serial devices"]):
            # Check if this is specifically about remote/screen session devices
            remote_system_keywords = ["remote", "screen", "screened", "other", "over usb", "over the usb", 
                                     "connected device", "on the screen", "in screen", "through screen",
                                     "remote system", "remote machine", "other os", "other machine"]
            
            is_remote_request = any(keyword in query_lower for keyword in remote_system_keywords)
            
            if is_remote_request and screen_exists:
                # This is a request about USB devices on a remote system via screen session
                if not hasattr(shell_handler, 'quiet_mode') or not shell_handler.quiet_mode:
                    print("ðŸ“± Checking for USB devices on remote system...")
                
                # Command for listing USB devices that works on most systems
                device_cmd = "ls -l /dev/tty* /dev/cu.* 2>/dev/null || ls -l /dev/ttyUSB* /dev/ttyACM* 2>/dev/null || dmesg | grep -i 'usb' | tail -20"
                
                # Send the command to the screen session
                result = shell_handler.send_to_screen_session(device_cmd)
                print(result)
                return
            
            # Local USB device check (not on remote system)
            if not hasattr(shell_handler, 'quiet_mode') or not shell_handler.quiet_mode:
                print("ðŸ“± Checking for connected USB and serial devices...")
            usb_devices = shell_handler.get_usb_devices()
            
            if not usb_devices or "No USB devices found" in usb_devices or "No USB devices detected" in usb_devices:
                print("No USB devices detected. Would you like to see all potential TTY/CU devices? (y/n)")
                response = input().strip().lower()
                if response == 'y' or response == 'yes':
                    print("Listing all potential TTY/CU devices:")
                    cmd = shell_handler.execute_command("ls -l /dev/cu.* /dev/tty.* 2>/dev/null || ls -l /dev/tty* 2>/dev/null")
                    print(cmd)
            else:
                # Print the device list without an additional header
                print(usb_devices)
            return
        
        # If no clear command match but USB mentioned, use enhanced USB device detection
        if not hasattr(shell_handler, 'quiet_mode') or not shell_handler.quiet_mode:
            print("Checking for connected USB devices...")
        usb_devices = shell_handler.get_usb_devices()
        # In quiet mode, we don't need an extra header since our enhanced output includes one
        print(usb_devices)
        return
    
    # ==========================================
    # STEP 9: Check if this is a direct command with no context
    # ==========================================
    
    # Check if this looks like a natural language query that should go to AI
    if is_natural_language_query(query_lower):
        # Skip to AI processing (STEP 10)
        command_pattern = None  # Initialize variable to avoid reference error
    else:
        # If we reach here, this might be a direct command without context
        # Check if it looks like a standard shell command that's not in our common list
        
        # Attempt to detect command pattern without relying on our whitelist
        command_pattern = re.search(r'^([\w\-\.\/]+)(?:\s+.*)?$', user_input_orig)
    
    if command_pattern:
        potential_command = command_pattern.group(1)
        # Check if this looks like a command (no spaces, mostly alphanumeric)
        if re.match(r'^[\w\-\.\/]+$', potential_command):
            # Try to detect if this should go to screen or local system
            target = shell_handler.detect_command_target(user_input_orig, query_lower)
            
            if target == "SCREEN":
                print(f"Sending command '{user_input_orig}' to active screen session...")
                result = shell_handler.send_to_screen_session(user_input_orig)
                print(result)
                return
            elif target == "LOCAL":
                print(f"Executing command locally: '{user_input_orig}'")
                cmd = shell_handler.execute_command(user_input_orig)
                print(cmd)
                return
    
    # ==========================================
    # STEP 10: Default to AI for command suggestion
    # ==========================================
            
    # Directly handle Wi-Fi speed queries and skip AI
    if any(k in query_lower for k in ['wifi speed', 'internet speed', 'speed test']):
        import platform, subprocess, re
        system_platform = platform.system().lower()
        print("âš¡ Checking network speed...")
        
        if system_platform == 'darwin':
            speed_info = {}
            
            # Method 1: Apple's airport utility for current tx/rx rates
            try:
                airport = "/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport"
                out = subprocess.check_output([airport, "-I"], text=True)
                
                # Get TX rate (transmission speed)
                tx_match = re.search(r"lastTxRate: (\d+)", out)
                if tx_match:
                    speed_info['tx_rate'] = int(tx_match.group(1))
                
                # Get signal strength
                rssi_match = re.search(r"agrCtlRSSI: (-?\d+)", out)
                if rssi_match:
                    rssi = int(rssi_match.group(1))
                    speed_info['signal_strength'] = rssi
                    
                    # Classify signal quality
                    if rssi > -50:
                        speed_info['signal_quality'] = "Excellent"
                    elif rssi > -60:
                        speed_info['signal_quality'] = "Very Good"
                    elif rssi > -70:
                        speed_info['signal_quality'] = "Good"
                    elif rssi > -80:
                        speed_info['signal_quality'] = "Fair"
                    else:
                        speed_info['signal_quality'] = "Poor"
            except Exception:
                pass
            
            # Method 2: networksetup for more connection details
            try:
                out = subprocess.check_output(["networksetup", "-getinfo", "Wi-Fi"], text=True)
                speed_match = re.search(r"Speed: (\d+)", out)
                if speed_match:
                    speed_info['link_speed'] = int(speed_match.group(1))
            except Exception:
                pass
                
            # Display the collected information in a clean format
            if speed_info:
                print("\nðŸ“¶ Wi-Fi Connection Information:")
                print("------------------------------")
                if 'tx_rate' in speed_info:
                    print(f"Current Speed: {speed_info['tx_rate']} Mbps")
                if 'link_speed' in speed_info:
                    print(f"Maximum Link Speed: {speed_info['link_speed']} Mbps")
                if 'signal_strength' in speed_info:
                    print(f"Signal Strength: {speed_info['signal_strength']} dBm ({speed_info['signal_quality']})")
                print("------------------------------")
            else:
                # Fallback to system_profiler if no information was collected
                try:
                    out = subprocess.check_output(["system_profiler", "SPNetworkDataType"], text=True)
                    wifi_section = re.search(r"Wi-Fi:.*?(?=^\S)", out, re.MULTILINE | re.DOTALL)
                    if wifi_section:
                        print("\nðŸ“¶ Wi-Fi Connection Details:")
                        print("------------------------------")
                        print(wifi_section.group(0).strip())
                        print("------------------------------")
                    else:
                        print("Could not determine Wi-Fi details.")
                except Exception:
                    print("Could not determine Wi-Fi details.")
                    
        elif system_platform in ['linux', 'ubuntu', 'jetson']:
            try:
                out = subprocess.check_output(["iwconfig"], stderr=subprocess.DEVNULL, text=True)
                speed_match = re.search(r"Bit Rate[=:]\s*(\d+\.?\d*)\s*Mb/s", out)
                quality_match = re.search(r"Link Quality[=:]\s*(\d+)/(\d+)", out)
                signal_match = re.search(r"Signal level[=:]\s*(-?\d+)\s*dBm", out)
                
                print("\nðŸ“¶ Wi-Fi Connection Information:")
                print("------------------------------")
                if speed_match:
                    print(f"Current Speed: {speed_match.group(1)} Mbps")
                if quality_match and int(quality_match.group(2)) > 0:
                    quality_percent = int(int(quality_match.group(1)) * 100 / int(quality_match.group(2)))
                    print(f"Link Quality: {quality_percent}%")
                if signal_match:
                    signal = int(signal_match.group(1))
                    quality = "Poor"
                    if signal > -50:
                        quality = "Excellent"
                    elif signal > -60:
                        quality = "Very Good"
                    elif signal > -70:
                        quality = "Good"
                    elif signal > -80:
                        quality = "Fair"
                    print(f"Signal Strength: {signal} dBm ({quality})")
                print("------------------------------")
            except Exception:
                print("Error: Could not retrieve Wi-Fi information. Make sure wireless tools are installed.")
        else:
            print("Error: Unsupported platform for Wi-Fi speed retrieval.")
        return

    # Determine the current platform
    import platform
    from core.utils import get_platform_name
    system_platform = platform.system().lower()
    platform_name = get_platform_name()
    
    # Platform-specific command examples
    platform_examples = ""
    if platform_name == "mac":
        platform_examples = """
        Examples of correct macOS commands:
        
        File Operations:
        - List files: ls -la
        - List files sorted by size: ls -S
        - Create empty file: touch filename.txt
        - Show file content: cat filename.txt
        - View file page by page: less filename.txt
        - Copy file: cp file1.txt file2.txt
        - Copy directory with contents: cp -r dir1 dir2
        - Move/rename file: mv old_name.txt new_name.txt
        - Delete file: rm filename.txt
        - Create directory: mkdir dirname
        - Remove directory: rm -r dirname
        - Show current directory: pwd
        
        Applications & URLs:
        - Open Chrome: open -a 'Google Chrome'
        - Open Chrome with URL: open -a 'Google Chrome' 'https://www.google.com'
        - Open URL in default browser: open 'https://www.google.com'
        - Open file with default app: open filename.txt
        - Open a text file for editing: open -t filename.txt
        - Search Google: open -a 'Google Chrome' 'https://www.google.com/search?q=search+term'
        - Open current directory in Finder: open .
        
        Media & System:
        - Play audio file: afplay audiofile.mp3
        - Text to speech: say "Hello world"
        - Check system processes: top
        - List all processes: ps aux
        - Kill a process: kill <pid>
        - Show disk usage: df -h
        - Show directory size: du -sh directory
        - Show date and time: date
        - Show calendar: cal
        - Show system uptime: uptime
        
        System Management:
        - Check for updates: softwareupdate -l
        - Install updates: sudo softwareupdate -i -a
        - Prevent system sleep: caffeinate
        - Search files by name: mdfind "filename"
        - Reset the Dock: killall Dock
        - Restart system: sudo shutdown -r now
        - Shutdown system: sudo shutdown -h now
        
        Networking:
        - Show network interfaces: ifconfig
        - Show routing table: netstat -r
        - DNS lookup: nslookup example.com
        - Check host connectivity: ping example.com
        - Show network path: traceroute example.com
        - Show Wi-Fi info: networksetup -getinfo Wi-Fi
        - Scan Wi-Fi networks: airport -s
        - Show open network ports: lsof -i -P | grep LISTEN
        
        IMPORTANT TIPS:
        - When opening applications with URLs, use format: open -a 'App Name' 'URL'
        - Use single quotes around paths with spaces
        - Avoid complex chains like '&&' or '||' unless you're sure they work on macOS
        """
    elif platform_name in ["ubuntu", "jetson"]:
        platform_examples = """
        Examples of correct Linux commands:
        - To open Chrome: google-chrome or chromium-browser
        - To open Chrome with a URL: google-chrome 'https://www.google.com'
        - To open a URL in default browser: xdg-open 'https://www.google.com'
        - To open a file: xdg-open filename.txt
        - To play audio: paplay audiofile.wav
        - To open file browser: nautilus .
        - To search Google: google-chrome 'https://www.google.com/search?q=search+term'
        """
    
    prompt_for_ai = (
        f"User request: '{user_input}'. "
        f"You are running on {system_platform} ({platform_name}). "
        f"Based on this request, suggest a single, common, and safe command specifically for {system_platform}. "
        "Avoid generating complex command chains (e.g., using ';', '&&', '||') unless the user's request explicitly implies it and it's a very common pattern. "
        "Do not provide explanations, only the command itself. "
        f"For macOS, use macOS-specific commands (like 'open -a' for applications). "
        f"For Linux, use Linux-specific commands. "
        f"{platform_examples}\n"
        "If the request is ambiguous or potentially unsafe to translate into a shell command, respond with 'Error: Cannot fulfill request safely.'"
    )

    ai_response_command = ai_handler.query_ai(prompt_for_ai)
    print(f"AI Suggested Command: {ai_response_command}")

    if ai_response_command and not ai_response_command.startswith("Error:"):
        safety_level = shell_handler.check_command_safety_level(ai_response_command)
        print(f"Command safety level: {safety_level}")
        # Auto-execute suggested command without prompts
        force_shell = safety_level in ['NOT_IN_WHITELIST', 'REQUIRES_SHELL_TRUE_ASSESSMENT']
        print(f"Executing command: {ai_response_command}")
        command_output = shell_handler.execute_command(ai_response_command, force_shell=force_shell)
        print(f"Command Output:\n{command_output}")
    elif ai_response_command.startswith("Error:"):
        print(f"AI Error: {ai_response_command}")
        print("Skipping execution due to AI error.")
    else:
        print("AI did not return a valid command string.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="UaiBot: AI-powered shell assistant.")
    parser.add_argument("-c", "--command", type=str, help="Execute a single command and exit.")
    parser.add_argument("-q", "--quiet", action="store_true", help="Run in quiet mode with minimal output")
    args = parser.parse_args()

    quiet_mode = args.quiet
    
    # Suppress warnings and stderr output in quiet mode
    if quiet_mode:
        import sys
        import os
        # Redirect stderr to null to suppress warnings
        f = open(os.devnull, 'w')
        old_stderr = sys.stderr
        sys.stderr = f
    
    # Helper function to print only when not in quiet mode
    def log(message, force=False):
        if force or not quiet_mode:
            print(message)

    config_data = load_config()
    if not config_data:
        exit(1)

    # --- Configuration Loading with Environment Variable Fallbacks ---
    ai_provider = config_data.get("default_ai_provider")
    if not ai_provider:
        log("Error: No default_ai_provider specified in config/settings.json.", force=True)
        log("Please set 'default_ai_provider' to either 'ollama' or 'google'.", force=True)
        exit(1)
        
    # Google API Key setup
    google_api_key = config_data.get("google_api_key")
    if ai_provider == "google" and (not google_api_key or google_api_key == "YOUR_GOOGLE_API_KEY"):
        env_key = os.getenv("GOOGLE_API_KEY")
        if env_key:
            google_api_key = env_key
            log("Using Google API key from environment variable.")
    
    # Ollama setup
    ollama_base_url = config_data.get("ollama_base_url")
    if not ollama_base_url:
        env_ollama_url = os.getenv("OLLAMA_BASE_URL")
        if env_ollama_url:
            ollama_base_url = env_ollama_url
        else:
            ollama_base_url = "http://localhost:11434"  # Default
    
    # Model settings
    default_ollama_model = config_data.get("default_ollama_model") or os.getenv("DEFAULT_OLLAMA_MODEL")
    default_google_model = config_data.get("default_google_model") or os.getenv("DEFAULT_GOOGLE_MODEL")
    
    # Shell settings
    shell_safe_mode = config_data.get("shell_safe_mode", True)
    shell_dangerous_check = config_data.get("shell_dangerous_check", True)
    
    # Debugging information (only in non-quiet mode)
    log(f"Using AI provider: {ai_provider}")
    if ai_provider == "ollama":
        log(f"Ollama URL: {ollama_base_url}, Model: {default_ollama_model}")
    elif ai_provider == "google":
        log(f"Google AI Model: {default_google_model}")

    # Initialize AI handler with error handling and fallback
    ai_handler = None
    try:
        if ai_provider == "google":
            if not google_api_key or google_api_key == "YOUR_GOOGLE_API_KEY":
                log("Error: Google API key not configured. Please set it in config/settings.json or as GOOGLE_API_KEY environment variable.", force=True)
                exit(1)
            if not default_google_model:
                log("Error: No default_google_model specified. Please set it in config/settings.json or as DEFAULT_GOOGLE_MODEL environment variable.", force=True)
                exit(1)
            ai_handler = AIHandler(model_type="google", api_key=google_api_key, google_model_name=default_google_model, quiet_mode=quiet_mode)
        
        elif ai_provider == "ollama":
            if not default_ollama_model:
                log("Error: No default_ollama_model specified. Please set it in config/settings.json or as DEFAULT_OLLAMA_MODEL environment variable.", force=True)
                exit(1)
            try:
                ai_handler = AIHandler(model_type="ollama", ollama_base_url=ollama_base_url, quiet_mode=quiet_mode)
                ai_handler.set_ollama_model(default_ollama_model) 
            except ConnectionError as e:
                log(f"Error connecting to Ollama (URL: {ollama_base_url}): {e}", force=True)
                
                if google_api_key and google_api_key != "YOUR_GOOGLE_API_KEY" and default_google_model:
                    log("Attempting to fall back to Google AI provider...", force=True)
                    try:
                        ai_handler = AIHandler(model_type="google", api_key=google_api_key, google_model_name=default_google_model, quiet_mode=quiet_mode)
                        log(f"Successfully connected to Google AI as fallback.", force=True)
                        ai_provider = "google"  # Update the effective AI provider
                    except Exception:
                        pass
                
                if not ai_handler:
                    log("ERROR: Could not connect to AI provider. Please check your configuration.", force=True)
                    exit(1)
        
        else:
            log(f"Error: Unknown AI provider '{ai_provider}'. Please use 'ollama' or 'google'.", force=True)
            exit(1)

    except ImportError as e:
        log(f"Error: Required libraries not installed - {e}", force=True)
        log("Run: pip install google-generativeai ollama", force=True)
        exit(1)
    except ValueError as e:
        log(f"Configuration Error: {e}", force=True)
        exit(1)
    except ConnectionError as e:
        log(f"Connection Error: {e}", force=True)
        log("Please ensure Ollama is running if using the ollama provider.", force=True)
        exit(1)

    if not ai_handler:
        log("Fatal: AI Handler could not be initialized.", force=True)
        exit(1)

    shell_handler = ShellHandler(safe_mode=shell_safe_mode, enable_dangerous_command_check=shell_dangerous_check, quiet_mode=quiet_mode)
    interactive_mode = config_data.get("interactive_mode", True)

    if args.command:  # If command is provided via CLI
        process_command(args.command, ai_handler, shell_handler)
        log("UaiBot command execution completed.", force=False)
    elif interactive_mode:  # Enter interactive loop when enabled
        try:
            while True:
                user_input = input("Enter your command (or type 'exit' to quit): ")
                if user_input.lower() == 'exit':
                    break
                process_command(user_input, ai_handler, shell_handler)
        except KeyboardInterrupt:
            log("\nExiting UaiBot.", force=True)
        finally:
            log("UaiBot session ended.", force=True)
    else:
        log("Interactive mode is disabled. Exiting.", force=True)