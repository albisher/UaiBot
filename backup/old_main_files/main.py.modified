import json
import argparse
import os
import sys
import re
import subprocess
from core.ai_handler import AIHandler
from core.shell_handler import ShellHandler
from core.utils import load_config, get_project_root
from core.command_help import CommandHelp
from platform_uai.platform_manager import PlatformManager

def process_command(user_input, ai_handler, shell_handler):
    """
    Processes a single user command, determining whether it should be executed
    locally or sent to a screen session. Handles a wide range of command patterns
    including all categories from enhancements2.txt.
    """
    if not user_input.strip():
        print("Please enter a command.")
        return
    
    query_lower = user_input.lower()
    user_input_orig = user_input  # Save original input with proper case
    
    # Check if there's a current screen context
    # This function sets a context flag to help decide where commands should go by default
    screen_exists = False
    try:
        result = subprocess.run(['screen', '-ls'], capture_output=True, text=True)
        screen_output = result.stdout + result.stderr
        if "No Sockets found" not in screen_output:
            screen_exists = True
    except Exception:
        screen_exists = False
    
    # ==========================================
    # STEP 1: First check for explicit screen session command indicators
    # ==========================================
    screen_session_indicators = [
        "screen session", "serial port", "usb terminal", "in screen", "on screen", 
        "to screen", "through screen", "via screen", "in the screen", "on the screen",
        "in terminal session", "in the terminal session", "over serial"
    ]
    
    explicitly_screen = any(indicator in query_lower for indicator in screen_session_indicators)
    
    # ==========================================
    # STEP 2: Check for commands that INITIATE screen sessions
    # ==========================================
    if query_lower.startswith("screen ") and any(term in query_lower for term in ['dev', 'cu', 'tty', 'serial', 'usb']):
        # This is likely a command to open a new screen session with a device
        cmd = shell_handler.execute_command(user_input_orig)
        print(cmd)
        return
    
    # ==========================================
    # STEP 3: Check for EXPLICIT send patterns
    # ==========================================
    if any(query_lower.startswith(prefix) for prefix in ["send ", "run ", "execute ", "type "]):
        # Direct command passing through "send" or similar patterns
        for prefix in ["send ", "run ", "execute ", "type "]:
            if query_lower.startswith(prefix):
                direct_cmd = user_input_orig.split(" ", 1)[1].strip()
                if direct_cmd:
                    if any(term in query_lower for term in ["screen", "terminal", "session", "serial"]):
                        # Explicit target is screen
                        print(f"Sending command '{direct_cmd}' to active screen session...")
                        result = shell_handler.send_to_screen_session(direct_cmd)
                        print(result)
                        return
                    elif screen_exists:
                        # No explicit target but screen exists, ask for confirmation
                        print(f"Would you like to send '{direct_cmd}' to the screen session? (y/n)")
                        response = input().strip().lower()
                        if response == 'y' or response == 'yes':
                            print(f"Sending command '{direct_cmd}' to active screen session...")
                            result = shell_handler.send_to_screen_session(direct_cmd)
                            print(result)
                            return
                        else:
                            # Execute locally
                            print(f"Executing command locally: '{direct_cmd}'")
                            cmd = shell_handler.execute_command(direct_cmd)
                            print(cmd)
                            return
                    else:
                        # No screen exists, run locally
                        print(f"Executing command locally: '{direct_cmd}'")
                        cmd = shell_handler.execute_command(direct_cmd)
                        print(cmd)
                        return
    
    # ==========================================
    # STEP 4: Handle DIRECT TERMINAL COMMANDS
    # ==========================================
    
    # Comprehensive list of all terminal commands from enhancements2.txt
    common_commands = [
        # File & directory operations
        'ls', 'pwd', 'cd', 'mkdir', 'rmdir', 'cp', 'mv', 'rm', 'touch', 'cat', 'find',
        # Text viewing/editing
        'more', 'less', 'head', 'tail', 'nano', 'vi', 'vim', 'grep', 'awk', 'sed',
        # System info
        'top', 'ps', 'kill', 'killall', 'df', 'du', 'free', 'uptime', 'date', 'cal', 'who', 'whoami',
        # Networking
        'ping', 'curl', 'wget', 'ssh', 'scp', 'ifconfig', 'netstat', 'traceroute', 'nslookup',
        # macOS specific
        'open', 'pbcopy', 'pbpaste', 'say', 'ditto', 'mdfind', 'diskutil',
        # Miscellaneous
        'echo', 'history', 'man', 'clear', 'alias', 'crontab'
    ]
    
    # Direct command with no args - check if it's a common terminal command
    command_base = query_lower.split()[0] if ' ' in query_lower else query_lower
    
    if command_base in common_commands and not query_lower.startswith(('make', 'tell', 'have')):
        # It's a direct command (e.g. "ls -la" or "pwd")
        
        # INTERACTIVE COMMANDS - more caution with screen sessions
        interactive_commands = ['nano', 'vi', 'vim', 'less', 'more', 'top', 'man']
        is_interactive = command_base in interactive_commands
        
        # If the command has arguments or it's an interactive command
        if ' ' in query_lower or is_interactive:
            if explicitly_screen:
                # User explicitly mentioned screen
                print(f"Sending command '{user_input_orig}' to active screen session...")
                result = shell_handler.send_to_screen_session(user_input_orig)
                print(result)
                return
            elif screen_exists:
                # For interactive commands, ask first since they require more interaction
                if is_interactive:
                    print(f"'{command_base}' is an interactive command. Send to screen session? (y/n)")
                    response = input().strip().lower()
                    if response == 'y' or response == 'yes':
                        print(f"Sending interactive command '{user_input_orig}' to active screen session...")
                        result = shell_handler.send_to_screen_session(user_input_orig)
                        print(result)
                        return
                
                # For non-interactive or user declined sending interactive command to screen
                print(f"Executing command locally: '{user_input_orig}'")
                cmd = shell_handler.execute_command(user_input_orig)
                print(cmd)
                return
            else:
                # No screen exists, run locally
                print(f"Executing command locally: '{user_input_orig}'")
                cmd = shell_handler.execute_command(user_input_orig)
                print(cmd)
                return
        else:
            # Simple command with no args, like just "ls" or "pwd"
            if explicitly_screen:
                # User explicitly mentioned screen
                print(f"Sending command '{user_input_orig}' to active screen session...")
                result = shell_handler.send_to_screen_session(user_input_orig)
                print(result)
                return
            elif screen_exists:
                # Screen exists but user didn't specify, give preference to screen for simple navigation commands
                navigation_commands = ['ls', 'pwd', 'cd', 'clear']
                if command_base in navigation_commands:
                    print(f"Sending command '{user_input_orig}' to active screen session...")
                    result = shell_handler.send_to_screen_session(user_input_orig)
                    print(result)
                    return
                else:
                    # For other commands, run locally by default
                    print(f"Executing command locally: '{user_input_orig}'")
                    cmd = shell_handler.execute_command(user_input_orig)
                    print(cmd)
                    return
            else:
                # No screen exists, run locally
                print(f"Executing command locally: '{user_input_orig}'")
                cmd = shell_handler.execute_command(user_input_orig)
                print(cmd)
                return
    
    # ==========================================
    # STEP 5: Check for complex command PATTERNS
    # ==========================================
    
    # Cases like "make it do X" or "tell screen to do X"
    import re
    command_match = None
    
    # If it's a phrase like "make it do ls" or "make screen do ls" or other variants
    if any(pattern in query_lower for pattern in ['make it', 'tell it', 'have it', 'make screen', 'tell screen']):
        patterns = [
            r'(?:make|tell|have)\s+(?:it|screen|terminal|session)\s+(?:do|run|execute|type)\s+[\'"]?([\w\s\-\.\/\*]+)[\'"]?',  # make it do X
            r'(?:in|on|at)\s+(?:the\s+)?(?:screen|terminal|session).*?(?:do|run|execute|type)\s+[\'"]?([\w\s\-\.\/\*]+)[\'"]',  # on screen do X
            r'(?:send|run|do|execute|type)\s+[\'"]?([\w\s\-\.\/\*]+)[\'"]?\s+(?:to|in|on|at)\s+(?:the\s+)?(?:screen|terminal|session)',  # send X to screen
        ]
        
        for pattern in patterns:
            match = re.search(pattern, query_lower)
            if match:
                command_match = match.group(1).strip()
                break
        
        if command_match:
            print(f"Sending command '{command_match}' to active screen session...")
            result = shell_handler.send_to_screen_session(command_match)
            print(result)
            return
        
        # Fallback for simple commands if no complex pattern matched
        for cmd in common_commands:
            if cmd in query_lower and any(term in query_lower for term in ['screen', 'terminal', 'session', 'serial']):
                print(f"Sending command '{cmd}' to active screen session...")
                result = shell_handler.send_to_screen_session(cmd)
                print(result)
                return
    
    # ==========================================
    # STEP 6: Check for other screen-related patterns
    # ==========================================
    
    # Handle other phrasings related to screen/terminal/session
    if ('screen' in query_lower and any(term in query_lower for term in ['send', 'run', 'do', 'execute', 'type', 'command'])) or \
       ('terminal' in query_lower and any(term in query_lower for term in ['screen', 'session', 'send', 'command'])) or \
       ('serial' in query_lower and any(term in query_lower for term in ['command', 'send', 'type'])) or \
       ('usb' in query_lower and any(term in query_lower for term in ['command', 'terminal', 'screen'])):
        
        # Try to extract the command using various patterns
        patterns = [
            r'(?:send|run|do|execute|type)\s+[\'"]?([\w\s\-\.\/\*]+)[\'"]?\s+(?:to|in|on|at)\s+(?:the\s+)?(?:screen|terminal|session)',  # send X to screen
            r'(?:screen|terminal|session).*?(?:do|run|execute|type)\s+[\'"]?([\w\s\-\.\/\*]+)[\'"]',  # make screen do X
            r'(?:in|on|at)\s+(?:the\s+)?(?:screen|terminal|session).*?(?:do|run|execute|type)\s+[\'"]?([\w\s\-\.\/\*]+)[\'"]',  # on screen do X
            r'(?:send|run|do|execute|type).*?[\'"]?([\w\s\-\.\/\*]+)[\'"]',  # generic fallback - try to find command after action words
        ]
        
        # If we still haven't found a command, check if user specifically mentioned common commands
        command_match = None
        
        for pattern in patterns:
            match = re.search(pattern, query_lower)
            if match:
                command_match = match.group(1).strip()
                break
        
        if not command_match:
            for cmd in common_commands:
                standalone_cmd_pattern = rf'\b{cmd}\b'
                if re.search(standalone_cmd_pattern, query_lower):
                    command_match = cmd
                    break
                
        # If we found a command, try to send it to the screen session
        if command_match:
            print(f"Sending command '{command_match}' to active screen session...")
            result = shell_handler.send_to_screen_session(command_match)
            print(result)
            return
    
    # ==========================================
    # STEP 7: Special handling for certain command types
    # ==========================================
    
    # Special handling for analyzing Wi-Fi speed
    if any(k in query_lower for k in ['wifi speed', 'internet speed', 'speed test']):
        import platform, subprocess, re
        system_platform = platform.system().lower()
        print("Retrieving Wi-Fi link speed...")
        if system_platform == 'darwin':
            try:
                # First try Apple's airport utility
                airport = "/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport"
                try:
                    out = subprocess.check_output([airport, "-I"], text=True)
                    m = re.search(r"lastTxRate: (\d+)", out)
                    if m:
                        print(f"Wi-Fi link speed: {m.group(1)} Mbps")
                    else:
                        # Fallback to networksetup command
                        out = subprocess.check_output(["networksetup", "-getinfo", "Wi-Fi"], text=True)
                        print(f"Wi-Fi connection info:\n{out}")
                except Exception:
                    # Fallback to system_profiler
                    out = subprocess.check_output(["system_profiler", "SPNetworkDataType"], text=True)
                    wifi_section = re.search(r"Wi-Fi:.*?(?=^\S)", out, re.MULTILINE | re.DOTALL)
                    if wifi_section:
                        print(f"Wi-Fi connection details:\n{wifi_section.group(0).strip()}")
                    else:
                        print("Could not determine Wi-Fi details.")
            except Exception as e:
                print(f"Error retrieving Wi-Fi speed: {e}")
        elif system_platform in ['linux', 'ubuntu', 'jetson']:
            try:
                out = subprocess.check_output(["iwconfig"], stderr=subprocess.DEVNULL, text=True)
                m = re.search(r"Bit Rate=(\d+\.?\d*) Mb/s", out)
                print(f"Wi-Fi link speed: {m.group(1)} Mbps" if m else "Could not determine Wi-Fi link speed.")
            except Exception:
                print("Error: 'iwconfig' command not available or failed.")
        else:
            print("Error: Unsupported platform for Wi-Fi speed retrieval.")
        return
    
    # ==========================================
    # STEP 8: Handle USB device commands that aren't explicit screen commands
    # ==========================================
    
    # Check for remote system related queries first
    remote_system_indicators = [
        "screened os", "remote device", "remote os", "remote system", 
        "remote machine", "other os", "other machine", "over usb connection", 
        "over my usb", "over the usb", "through screen", "in screen session",
        "other system", "screened system", "connected system", "device usb"
    ]
    
    # If remote system terms were used and asking about USB devices
    if any(indicator in query_lower for indicator in remote_system_indicators) and screen_exists:
        if any(term in query_lower for term in ["usb", "device", "serial", "port", "connected"]):
            # This is likely asking about USB devices on remote system
            if not hasattr(shell_handler, 'quiet_mode') or not shell_handler.quiet_mode:
                print(f"Checking for USB devices on remote system...")
            
            # Choose the appropriate command based on the context
            device_cmd = None
            if "list" in query_lower or "show" in query_lower:
                # More detailed listing of devices requested
                device_cmd = "ls -l /dev/tty* /dev/cu.* 2>/dev/null || ls -l /dev/ttyUSB* /dev/ttyACM* 2>/dev/null"
            elif "dmesg" in query_lower or "logs" in query_lower:
                # Get USB-related system logs
                device_cmd = "dmesg | grep -i usb | tail -20"
            else:
                # Default command - comprehensive detection that works on most systems
                device_cmd = "echo 'ðŸ“± USB Devices on Remote System:' && echo '' && " + \
                             "ls -l /dev/tty* /dev/cu.* 2>/dev/null || ls -l /dev/ttyUSB* /dev/ttyACM* 2>/dev/null && " + \
                             "echo '' && echo 'ðŸ” USB Hardware Information:' && echo '' && " + \
                             "lsusb 2>/dev/null || system_profiler SPUSBDataType 2>/dev/null || dmesg | grep -i usb | tail -10"
            
            result = shell_handler.send_to_screen_session(device_cmd)
            print(result)
            return

    # Check for USB device mentions without explicit screen command patterns
    if any(term in query_lower for term in ['usb', 'serial', 'tty', 'dev/cu', 'dev/tty', 'connected device', 'port', 'usb screen', 'connected screen']):
        # This is likely a USB device operation, try to extract a command
        device_command_patterns = [
            r'(?:on|to|with|in|at|via|through)\s+(?:the\s+)?(?:usb|serial|device|port|connection).*?(?:do|run|execute|type|send|show|list|display)\s+[\'"]?([\w\s\-\.\/\*\>\<\|\&]+)[\'"]',  # on usb do X
            r'(?:do|run|execute|type|send|show|list|display)\s+[\'"]?([\w\s\-\.\/\*\>\<\|\&]+)[\'"].*?(?:on|to|with|in|at|via|through)\s+(?:the\s+)?(?:usb|serial|device|port|connection)',  # do X on usb
            r'(?:usb|serial|device|port|connection).*?(?:should|could|must|please)?\s+(?:do|run|execute|type|send|show|list|display)\s+[\'"]?([\w\s\-\.\/\*\>\<\|\&]+)[\'"]',  # usb show X
        ]
        
        for pattern in device_command_patterns:
            match = re.search(pattern, query_lower)
            if match:
                command_match = match.group(1).strip()
                print(f"Sending command '{command_match}' to active USB/screen session...")
                result = shell_handler.send_to_screen_session(command_match)
                print(result)
                return
        
        # Special handling for USB device detection commands
        if any(term in query_lower for term in ["list devices", "show devices", "connected usb", "check usb", "find usb",
                                              "list usb", "detect usb", "show connected", "what usb", "usb devices",
                                              "serial devices"]):
            # Only print status message if not in quiet mode
            if not hasattr(shell_handler, 'quiet_mode') or not shell_handler.quiet_mode:
                print("ðŸ“± Checking for connected USB and serial devices...")
            usb_devices = shell_handler.get_usb_devices()
            
            if not usb_devices or "No USB devices found" in usb_devices or "No USB devices detected" in usb_devices:
                print("No USB devices detected. Would you like to see all potential TTY/CU devices? (y/n)")
                response = input().strip().lower()
                if response == 'y' or response == 'yes':
                    print("Listing all potential TTY/CU devices:")
                    cmd = shell_handler.execute_command("ls -l /dev/cu.* /dev/tty.* 2>/dev/null || ls -l /dev/tty* 2>/dev/null")
                    print(cmd)
            else:
                # Print the device list without an additional header
                print(usb_devices)
            return
            
        # If no clear command match but USB mentioned, use enhanced USB device detection
        if not hasattr(shell_handler, 'quiet_mode') or not shell_handler.quiet_mode:
            print("Checking for connected USB devices...")
        usb_devices = shell_handler.get_usb_devices()
        # In quiet mode, we don't need an extra header since our enhanced output includes one
        print(usb_devices)
        return
    
    # ==========================================
    # STEP 9: Check if this is a direct command with no context
    # ==========================================
    
    # If we reach here, this might be a direct command without context
    # Check if it looks like a standard shell command that's not in our common list
    
    # Attempt to detect command pattern without relying on our whitelist
    command_pattern = re.search(r'^([\w\-\.\/]+)(?:\s+.*)?$', user_input_orig)
    
    if command_pattern:
        potential_command = command_pattern.group(1)
        # Check if this looks like a command (no spaces, mostly alphanumeric)
        if re.match(r'^[\w\-\.\/]+$', potential_command):
            # Try to detect if this should go to screen or local system
            target = shell_handler.detect_command_target(user_input_orig, query_lower)
            
            if target == "SCREEN":
                print(f"Sending command '{user_input_orig}' to active screen session...")
                result = shell_handler.send_to_screen_session(user_input_orig)
                print(result)
                return
            elif target == "LOCAL":
                print(f"Executing command locally: '{user_input_orig}'")
                cmd = shell_handler.execute_command(user_input_orig)
                print(cmd)
                return
    
    # ==========================================
    # STEP 10: Check if this is a help request for a command
    # ==========================================
    
    help_keywords = ['help', 'how to', 'usage', 'manual', 'man', 'info', 'examples', 'explain']
    is_help_request = any(keyword in query_lower for keyword in help_keywords)
    
    # Look for command mentions in a help request context
    if is_help_request:
        # Check if any known command is mentioned
        for command in CommandHelp.list_available_commands():
            # Look for the command as a standalone word
            pattern = rf'\b{re.escape(command)}\b'
            if re.search(pattern, query_lower):
                # Found a command help request
                help_info = CommandHelp.get_command_help(command)
                if help_info:
                    print(f"\n======= Help: {command} =======")
                    print(f"Description: {help_info['description']}")
                    print(f"Syntax: {help_info['syntax']}")
                    print("\nExamples:")
                    for example in help_info['examples']:
                        print(f"  {example}")
                    print(f"Categories: {', '.join(help_info['categories'])}")
                    print("=============================\n")
                    return
        
        # If they asked for help with a category
        for category in ['file', 'directory', 'system', 'network', 'text', 'editor', 'automation']:
            if category in query_lower:
                commands = CommandHelp.get_command_category(category)
                if commands:
                    print(f"\n======= Commands in '{category}' category =======")
                    for cmd in commands:
                        help_info = CommandHelp.get_command_help(cmd)
                        print(f"- {cmd}: {help_info['description']}")
                    print("\nFor detailed help on a specific command, type 'help [command]'")
                    print("=========================================\n")
                    return
    
    # ==========================================
    # STEP 11: Default to AI for command suggestion
    # ==========================================
            
    # Directly handle Wi-Fi speed queries and skip AI
    if any(k in query_lower for k in ['wifi speed', 'internet speed', 'speed test']):
        import platform, subprocess, re
        system_platform = platform.system().lower()
        print("Retrieving Wi-Fi link speed...")
        if system_platform == 'darwin':
            try:
                # First try Apple's airport utility
                airport = "/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport"
                try:
                    out = subprocess.check_output([airport, "-I"], text=True)
                    m = re.search(r"lastTxRate: (\d+)", out)
                    if m:
                        print(f"Wi-Fi link speed: {m.group(1)} Mbps")
                    else:
                        # Fallback to networksetup command
                        out = subprocess.check_output(["networksetup", "-getinfo", "Wi-Fi"], text=True)
                        print(f"Wi-Fi connection info:\n{out}")
                except Exception:
                    # Fallback to system_profiler
                    out = subprocess.check_output(["system_profiler", "SPNetworkDataType"], text=True)
                    wifi_section = re.search(r"Wi-Fi:.*?(?=^\S)", out, re.MULTILINE | re.DOTALL)
                    if wifi_section:
                        print(f"Wi-Fi connection details:\n{wifi_section.group(0).strip()}")
                    else:
                        print("Could not determine Wi-Fi details.")
            except Exception as e:
                print(f"Error retrieving Wi-Fi speed: {e}")
        elif system_platform in ['linux', 'ubuntu', 'jetson']:
            try:
                out = subprocess.check_output(["iwconfig"], stderr=subprocess.DEVNULL, text=True)
                m = re.search(r"Bit Rate=(\d+\.?\d*) Mb/s", out)
                print(f"Wi-Fi link speed: {m.group(1)} Mbps" if m else "Could not determine Wi-Fi link speed.")
            except Exception:
                print("Error: 'iwconfig' command not available or failed.")
        else:
            print("Error: Unsupported platform for Wi-Fi speed retrieval.")
        return

    # Determine the current platform
    import platform
    from core.utils import get_platform_name
    system_platform = platform.system().lower()
    platform_name = get_platform_name()
    
    # Platform-specific command examples
    platform_examples = ""
    if platform_name == "mac":
        platform_examples = """
        Examples of correct macOS commands:
        
        File Operations:
        - List files: ls -la
        - List files sorted by size: ls -S
        - Create empty file: touch filename.txt
        - Show file content: cat filename.txt
        - View file page by page: less filename.txt
        - Copy file: cp file1.txt file2.txt
        - Copy directory with contents: cp -r dir1 dir2
        - Move/rename file: mv old_name.txt new_name.txt
        - Delete file: rm filename.txt
        - Create directory: mkdir dirname
        - Remove directory: rm -r dirname
        - Show current directory: pwd
        
        Applications & URLs:
        - Open Chrome: open -a 'Google Chrome'
        - Open Chrome with URL: open -a 'Google Chrome' 'https://www.google.com'
        - Open URL in default browser: open 'https://www.google.com'
        - Open file with default app: open filename.txt
        - Open a text file for editing: open -t filename.txt
        - Search Google: open -a 'Google Chrome' 'https://www.google.com/search?q=search+term'
        - Open current directory in Finder: open .
        
        Media & System:
        - Play audio file: afplay audiofile.mp3
        - Text to speech: say "Hello world"
        - Check system processes: top
        - List all processes: ps aux
        - Kill a process: kill <pid>
        - Show disk usage: df -h
        - Show directory size: du -sh directory
        - Show date and time: date
        - Show calendar: cal
        - Show system uptime: uptime
        
        System Management:
        - Check for updates: softwareupdate -l
        - Install updates: sudo softwareupdate -i -a
        - Prevent system sleep: caffeinate
        - Search files by name: mdfind "filename"
        - Reset the Dock: killall Dock
        - Restart system: sudo shutdown -r now
        - Shutdown system: sudo shutdown -h now
        
        Networking:
        - Show network interfaces: ifconfig
        - Show routing table: netstat -r
        - DNS lookup: nslookup example.com
        - Check host connectivity: ping example.com
        - Show network path: traceroute example.com
        - Show Wi-Fi info: networksetup -getinfo Wi-Fi
        - Scan Wi-Fi networks: airport -s
        - Show open network ports: lsof -i -P | grep LISTEN
        
        IMPORTANT TIPS:
        - When opening applications with URLs, use format: open -a 'App Name' 'URL'
        - Use single quotes around paths with spaces
        - Avoid complex chains like '&&' or '||' unless you're sure they work on macOS
        """
    elif platform_name in ["ubuntu", "jetson"]:
        platform_examples = """
        Examples of correct Linux commands:
        - To open Chrome: google-chrome or chromium-browser
        - To open Chrome with a URL: google-chrome 'https://www.google.com'
        - To open a URL in default browser: xdg-open 'https://www.google.com'
        - To open a file: xdg-open filename.txt
        - To play audio: paplay audiofile.wav
        - To open file browser: nautilus .
        - To search Google: google-chrome 'https://www.google.com/search?q=search+term'
        """
    
    prompt_for_ai = (
        f"User request: '{user_input}'. "
        f"You are running on {system_platform} ({platform_name}). "
        f"Based on this request, suggest a single, common, and safe command specifically for {system_platform}. "
        "Avoid generating complex command chains (e.g., using ';', '&&', '||') unless the user's request explicitly implies it and it's a very common pattern. "
        "Do not provide explanations, only the command itself. "
        f"For macOS, use macOS-specific commands (like 'open -a' for applications). "
        f"For Linux, use Linux-specific commands. "
        f"{platform_examples}\n"
        "If the request is ambiguous or potentially unsafe to translate into a shell command, respond with 'Error: Cannot fulfill request safely.'"
    )

    ai_response_command = ai_handler.query_ai(prompt_for_ai)
    print(f"AI Suggested Command: {ai_response_command}")

    if ai_response_command and not ai_response_command.startswith("Error:"):
        safety_level = shell_handler.check_command_safety_level(ai_response_command)
        print(f"Command safety level: {safety_level}")
        # Auto-execute suggested command without prompts
        force_shell = safety_level in ['NOT_IN_WHITELIST', 'REQUIRES_SHELL_TRUE_ASSESSMENT']
        print(f"Executing command: {ai_response_command}")
        command_output = shell_handler.execute_command(ai_response_command, force_shell=force_shell)
        print(f"Command Output:\n{command_output}")
    elif ai_response_command.startswith("Error:"):
        print(f"AI Error: {ai_response_command}")
        print("Skipping execution due to AI error.")
    else:
        print("AI did not return a valid command string.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="UaiBot: AI-powered shell assistant.") # Added argument parser
    parser.add_argument("-c", "--command", type=str, help="Execute a single command and exit.")
    parser.add_argument("-q", "--quiet", action="store_true", help="Run in quiet mode with minimal output")
    args = parser.parse_args()

    config_data = load_config() # Renamed to avoid conflict with 'config' module if ever imported
    if not config_data:
        exit(1)

    # --- Configuration Loading with Environment Variable Fallbacks ---
    ai_provider = config_data.get("default_ai_provider")
    if not ai_provider:
        log("Error: No default_ai_provider specified in config/settings.json.", force=True, quiet_mode=quiet_mode)
        log("Please set 'default_ai_provider' to either 'ollama' or 'google'.", force=True, quiet_mode=quiet_mode)
        exit(1)
        
    google_api_key = config_data.get("google_api_key")
    if not google_api_key or google_api_key == "YOUR_GOOGLE_API_KEY":
        log("Google API key not in config or is placeholder, checking GOOGLE_API_KEY env var...")
        env_key = os.getenv("GOOGLE_API_KEY")
        if env_key:
            google_api_key = env_key
            log("Using Google API key from GOOGLE_API_KEY environment variable.")
        # If still not found or placeholder, it will be checked later if provider is 'google' or for fallback

    ollama_base_url = config_data.get("ollama_base_url")
    if not ollama_base_url:
        print("Ollama base URL not in config, checking OLLAMA_BASE_URL env var...")
        env_ollama_url = os.getenv("OLLAMA_BASE_URL")
        if env_ollama_url:
            ollama_base_url = env_ollama_url
            print("Using Ollama base URL from OLLAMA_BASE_URL environment variable.")
        else:
            ollama_base_url = "http://localhost:11434" # Default
            print(f"Warning: No ollama_base_url specified in config or OLLAMA_BASE_URL env var. Using default: {ollama_base_url}")
    
    default_ollama_model = config_data.get("default_ollama_model")
    if not default_ollama_model:
        print("Default Ollama model not in config, checking DEFAULT_OLLAMA_MODEL env var...")
        env_ollama_model = os.getenv("DEFAULT_OLLAMA_MODEL")
        if env_ollama_model:
            default_ollama_model = env_ollama_model
            print("Using default Ollama model from DEFAULT_OLLAMA_MODEL environment variable.")
        
    default_google_model = config_data.get("default_google_model")
    if not default_google_model:
        print("Default Google model not in config, checking DEFAULT_GOOGLE_MODEL env var...")
        env_google_model = os.getenv("DEFAULT_GOOGLE_MODEL")
        if env_google_model:
            default_google_model = env_google_model
            print("Using default Google model from DEFAULT_GOOGLE_MODEL environment variable.")
        
    shell_safe_mode = config_data.get("shell_safe_mode", True)
    shell_dangerous_check = config_data.get("shell_dangerous_check", True)

    print(f"Using AI provider: {ai_provider}")
    print(f"Shell safe_mode: {shell_safe_mode}, dangerous_command_check: {shell_dangerous_check}")

    # Initialize AI handler with error handling and fallback
    # Set up quiet mode if specified
    quiet_mode = args.quiet if hasattr(args, 'quiet') else False
    
    ai_handler = None
    try:
        if ai_provider == "google":
            if not google_api_key or google_api_key == "YOUR_GOOGLE_API_KEY":
                log("Error: Google API key not configured. Please set it in config/settings.json or as GOOGLE_API_KEY environment variable.", force=True)
                exit(1)
            if not default_google_model:
                log("Error: No default_google_model specified. Please set it in config/settings.json or as DEFAULT_GOOGLE_MODEL environment variable.", force=True)
                exit(1)
            ai_handler = AIHandler(model_type="google", api_key=google_api_key, google_model_name=default_google_model, quiet_mode=quiet_mode)
        elif ai_provider == "ollama":
            if not default_ollama_model: # Check if model name is available
                print("Error: No default_ollama_model specified. Please set it in config/settings.json or as DEFAULT_OLLAMA_MODEL environment variable.")
                exit(1)
            try:
                ai_handler = AIHandler(model_type="ollama", ollama_base_url=ollama_base_url, quiet_mode=quiet_mode)
                ai_handler.set_ollama_model(default_ollama_model) 
            except ConnectionError as e:
                print(f"Error connecting to Ollama (URL: {ollama_base_url}): {e}")
                print("Ollama connection failed. Is Ollama installed and running?")
                
                if google_api_key and google_api_key != "YOUR_GOOGLE_API_KEY" and default_google_model:
                    print("Attempting to fall back to Google AI provider...")
                    try:
                        ai_handler = AIHandler(model_type="google", api_key=google_api_key, google_model_name=default_google_model, quiet_mode=quiet_mode)
                        log(f"Successfully connected to Google AI with model: {default_google_model} as fallback.", force=True)
                        ai_provider = "google" # Update the effective AI provider
                    except Exception as google_fallback_e:
                        print(f"Error initializing Google AI as fallback: {google_fallback_e}")
                        # ai_handler remains None or as it was, will be caught by the final check
                else:
                    print("Google API key and/or default Google model not configured for fallback.")
                
                if not ai_handler: # If fallback failed or wasn't attempted/configured
                    print("ERROR: Could not connect to Ollama, and fallback to Google AI was not successful or not configured.")
                    print("Please either:")
                    print(f"1. Start Ollama (expected at {ollama_base_url}) by running 'ollama serve' in another terminal, OR")
                    print("2. Configure a valid Google API key and model in config/settings.json or environment variables.")
                    exit(1)
        else:
            print(f"Error: Unknown AI provider '{ai_provider}' in config/settings.json.")
            print("Please set 'default_ai_provider' to either 'ollama' or 'google'.")
            exit(1)

    except ImportError as e:
        print(f"Error initializing AI Handler: {e} - {e.__class__.__name__}")
        print("Please ensure the required libraries (google-generativeai or ollama) are installed.")
        print("Run: pip install google-generativeai ollama")
        exit(1)
    except ValueError as e:
        print(f"Configuration Error: {e} - {e.__class__.__name__}")
        exit(1)
    except ConnectionError as e: # This specific catch might be less relevant now or could be for other components
        print(f"Connection Error: {e} - {e.__class__.__name__}")
        print("Please ensure Ollama is running. Try starting it with 'ollama serve' in another terminal.")
        exit(1)

    if not ai_handler: # Final check to ensure AI Handler is initialized
        print("Fatal: AI Handler could not be initialized. Please check your configuration, AI provider status, and previous error messages.")
        exit(1)

    shell_handler = ShellHandler(safe_mode=shell_safe_mode, enable_dangerous_command_check=shell_dangerous_check, quiet_mode=quiet_mode)
    # Determine if interactive mode is enabled in config (default: True)
    interactive_mode = config_data.get("interactive_mode", True)

    if args.command:  # If command is provided via CLI
        process_command(args.command, ai_handler, shell_handler)
        print("UaiBot single command execution finished.")
    elif interactive_mode:  # Enter interactive loop when enabled
        try:
            while True:
                user_input = input("Enter your command (or type 'exit' to quit): ")
                if user_input.lower() == 'exit':
                    break
                process_command(user_input, ai_handler, shell_handler)
        except KeyboardInterrupt:
            print("\nExiting UaiBot.")
        finally:
            print("UaiBot session ended.")
    else:
        print("Interactive mode is disabled. Exiting.")